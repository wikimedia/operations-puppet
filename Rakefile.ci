# This rakefile is meant to run linters and tests
# tailored to a specific changeset.
# You will need 'bundler' to install dependencies:
#
#  $ apt-get install bundler
#  $ bundle install
#
# Then run all the tests, in parallel, that are pertinent to the current changeset
#
#   $ bundle exec rake test
#
# If you just want to check which tests would be ran, run
#
#   $ bundle exec rake debug
#
# Based on the contents of the change, this rakefile will define and run
# all or just some of the following tests:
#
# * puppet_lint - runs puppet lint on the changed puppet files
# * typos - checks the changed files against a predefined list of typos defined
#            in ./typos
# * syntax - run syntax checks for puppet files, hiera files, and templates
#            changed in the current changeset
# * rubocop - run rubocop style checks on ruby files changed in this changeset
# * spec - run the spec tests on the modules where files are changed, or whose
#           tests depend on modules that have been modified.
#
require 'git'
require 'set'
require 'rake'
require 'rake/tasklib'

require 'puppet-lint/tasks/puppet-lint'
require 'puppet-syntax'
require 'puppet-syntax/tasks/puppet-syntax'
require 'rubocop/rake_task'



# Monkey-patch PuppetSyntax and its rake task
module PuppetSyntax
  @manifests_paths = ["**/*.pp"]
  @templates_paths = ["**/*.erb"]
  class << self
    attr_accessor :manifests_paths, :templates_paths
  end
end

class PuppetSyntax::RakeTask
  def filelist_manifests
    filelist(PuppetSyntax.manifests_paths)
  end

  def filelist_templates
    filelist(PuppetSyntax.templates_paths)
  end
end

class SpecDependencies
  # Finds all specs to run based on the changed modules.

  def initialize()
    @deps = {}
    FileList["modules/*/.fixtures.yml"].each do |file|
      module_name = module_from_filename(file)
      symlinks = YAML.safe_load(File.open(file))['fixtures']['symlinks'].keys.select{ |x| x != module_name }
      symlinks.each do |dependency|
        @deps[dependency]||= []
        @deps[dependency] << module_name
      end
    end
  end

  def specs_to_run(filelist)
    specs = Set.new
    modules = modules_modified(filelist)
    return [] if !modules
    modules.each do |mod|
      next unless Dir.exists("#{mod}/spec")
      specs.add(mod)
      if @deps.include?mod
        @deps[mod].each{ |m| specs.add(m) }
      end
    end
    specs.to_a
  end

  private
  def modules_modified(filelist)
    modules = Set.new
    filelist.each do |file|
      module_name = module_from_filename(file)

      modules.add(module_name) if module_name
    end
    modules.to_a
  end


  def module_from_filename(name)
    if %r{modules/([^/]+)} =~ name
      Regexp.last_match(1)
    else
      nil
    end
  end
end

class TaskGen < ::Rake::TaskLib

  def initialize(path)
    setup_tasks_list
    @changed_files = git_changed_in_head(path)
    @file_buckets = fill_file_buckets
  end

  def all_tasks
    TaskGen.class_variable_get(:@@tasks_list)
  end

  def tasks
    all_tasks.select{ |x| @file_buckets[x] }
  end

  private
  def setup_tasks_list
    TaskGen.class_variable_set(
      :@@tasks_list,
      [
        :puppet_lint,
        :typos,
        :syntax,
        :rubocop,
        :spec
      ]
    )
  end

  def git_changed_in_head(path)
    g = Git.open(path)
    diff = g.diff('HEAD^')
    diff.name_status.select { |_, status| 'ACM'.include? status}.keys
  end

  def fill_file_buckets
    buckets = {}
    all_tasks.each do |task|
      method_name = "setup_#{task}"
      buckets[task] = send(method_name)
    end
    buckets
  end

  def puppet_changed_files
    @changed_files.select{ |x| File.fnmatch("*.pp", x) }
  end

  def filter_files_by(*globs)
    changed = FileList[@changed_files]
    changed.exclude(*PuppetSyntax.exclude_paths).select do |file|
      # If at least one glob pattern matches, the file is included.
      !globs.select{ |glob| File.fnmatch(glob, file)}.empty?
    end
  end

  def setup_puppet_lint
    changed = puppet_changed_files
    return false if changed.empty?
    # Reset puppet-lint tasks, define a new one
    Rake::Task[:lint].clear
    PuppetLint::RakeTask.new :puppet_lint do |config|
      config.fail_on_warnings = true  # be strict
      config.log_format = '%{path}:%{line} %{KIND} %{message} (%{check})'
      config.pattern = changed
    end
    true
  end

  def setup_typos
    return false if @changed_files.empty?
    # TODO: use some shell quoting library maybe?
    shell_files = @changed_files.map{ |x| "'#{x}'" }.join " "
    desc "Check common typos from /typos"
    task :typos do
      system("git grep -q -I -P -f typos -- #{shell_files}")
      case $CHILD_STATUS.exitstatus
      when 0
        fail "Typo found!"
      when 1
        puts "No typo found."
      else
        fail "Some error occured"
      end
    end
    true
  end

  def setup_syntax
    # Reset puppet-syntax tasks, define a new one
    Rake::Task[:syntax].clear

    # site.pp still uses an import statement for realm.pp (T154915)
    # We can think of activating this once we've moved to the future parser
    PuppetSyntax.fail_on_deprecation_notices = false
    if Puppet.version.to_f < 4.0
      PuppetSyntax.exclude_paths = [
        'modules/stdlib/types/*.pp',
        'modules/stdlib/types/compat/*.pp',
        'modules/stdlib/spec/fixtures/test/manifests/*.pp',
      ]
    end
    # Set up filelists
    PuppetSyntax.manifests_paths = puppet_changed_files
    PuppetSyntax.templates_paths = filter_files_by("**/templates/**/*.erb", "**/templates/**/*.epp")
    PuppetSyntax.hieradata_paths = filter_files_by("hieradata/**/*.yaml", "conftool-data/**/*.yaml")
    tasks = []
    unless PuppetSyntax.manifests_paths.empty?
      tasks << 'syntax:manifests'
    end
    unless PuppetSyntax.templates_paths.empty?
      tasks << 'syntax:templates'
    end
    unless PuppetSyntax.hieradata_paths.empty?
      tasks << 'syntax:hiera'
    end
    return false if tasks.empty?
    # Now re-set up the jobs by instantiating the class
    PuppetSyntax::RakeTask.new
    true
  end

  def setup_rubocop
    # TODO: use rubocop itself?
    ruby_files = filter_files_by("**/*.rb", "**/Rakefile", 'Gemfile')
    return false if ruby_files.empty?
    rubocop_task = RuboCop::RakeTask.new(:rubocop)
    # If the gemfile changed, we might have updated rubocop.
    # Err on the side of caution and scan all files in that case.
    if !@changed_files.include?('Gemfile')
      rubocop_task.patterns = ruby_files
    end
  end

  def setup_spec
    deps = SpecDependencies.new
    spec_modules = deps.specs_to_run(@changed_files)
    return false if spec_modules.empty?
    namespace :spec do
      spec_modules.each do |module_name|
        desc "Run spec for module #{module_name}"
        task module_name do
          puts '-' * 80
          puts "Running rspec tests for module #{module_name}"
          puts '-' * 80
          spec_result = system("cd 'modules/#{module_name}' && rake spec")
          raise "Module #{module_name} failed to pass spec" if !spec_result
        end
      end
    end
  end
end


t = TaskGen.new('.')

desc 'Run all actual tests in parallel for changes in HEAD'
multitask :test => t.tasks

# Show what we would run
task :debug do
  puts "Tasks that would be run: "
  puts t.tasks
end


desc 'Show the help'
task :help do
  puts "Puppet helper for operations/puppet.git

Welcome #{ENV['USER']} to WMFs wonderful rake helper to play with puppet.

---[Command line options]----------------------------------------------
`rake -T` : list available tasks
`rake -P` : shows tasks dependencies

---[Available rake tasks]----------------------------------------------"

  # Show our tasks list.
  system "rake -T"

  puts "-----------------------------------------------------------------------"
end
