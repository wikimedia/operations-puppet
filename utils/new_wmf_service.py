#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  new_service -- shell helper for automating introduction of a new service

  Usage: ./new_service.py

  Requirements: Running it from the utils/ directory

  Copyright 2015 Alexandros Kosiaris <akosiaris@wikimedia.org>
  Licensed under the Apache license.
"""

import re
import os
import argparse

QUESTIONS = [
    {
        'qname': 'service_name',
        'qstring': 'What will be the name of the service',
        'validator': lambda x: True if re.match('^[a-z_-]{6,20}$', x) else False,
        'transformer': lambda x: x,
    },
    {
        'qname': 'service_description',
        'qstring': 'A one line description of the service',
        'validator': lambda x: True if re.match('^[\w\s\.-]+$', x) else False,
        'transformer': lambda x: x,
    },
    {
        'qname': 'service_node',
        'qstring': 'Does it adhere to the service::node paradigm (Y/n)',
        'validator': lambda x: True if re.match('^[Yy]([Ee][Ss])?|[Nn]([Oo])?|$', x) else False,
        'transformer': lambda x: True if re.match('^[Yy]([Ee][Ss])?|$', x) else False,
    },
    {
        'qname': 'port',
        'qstring': 'Which TCP port does it listen on?',
        'validator': lambda x: True if re.match('^[0-9]{4,5}$', x) else False,
        'transformer': lambda x: x,
    },
    {
        'qname': 'hosts',
        'qstring': 'Which hosts will serve it (comma separated)',
        'validator': lambda x: True if re.match('^([a-z0-9]+\.(eqiad|codfw)\.wmnet(,)?)+$', x) else False,
        'transformer': lambda x: x.split(','),
    },
    {
        'qname': 'repo',
        'qstring': 'Repo name in gerrit',
        'validator': lambda x: True if re.match('^http(s)?://gerrit.wikimedia.org/r/', x) else False,
        'transformer': lambda x: x,
    },
    {
        'qname': 'lvs_class',
        'qstring': 'Which LVS class shall serve it (low-traffic)',
        'validator': lambda x: True if re.match('^[a-z-]+$', x) else False,
        'transformer': lambda x: 'low-traffic',  # TODO: Actually code this
    },
    {
        'qname': 'lvs_hostname',
        'qstring': 'LVS Hostname',
        'validator': lambda x: True if re.match('^[a-z0-9]+\.svc\.(eqiad|codfw)\.wmnet$', x) else False,
        'transformer': lambda x: x,
    },
    {
        'qname': 'lvs_ip',
        'qstring': 'LVS IP',
        # TODO: Perhaps write a better validator
        'validator': lambda x: True if re.match('^10(\.[0-9]{1,3}){3}$', x) else False,
        'transformer': lambda x: x,
    },
]


class Service():

    def __init__(self, data):
        for k, v in data.items():
            setattr(self, k, v)

    def __str__(self):
        return '%s' % self.service_name

    def __unicode__(self):
        return u'%s' % self.__str__()

    def create_puppet_module(self):
        # Keep cwd
        cwd = os.getcwd()
        os.chdir('..')

        # Create directories
        try:
            os.makedirs('modules/%s/manifests/' % self.service_name)
            os.makedirs('modules/%s/tests/' % self.service_name)
            os.makedirs('modules/%s/templates/' % self.service_name)
        except OSError as e:
            print 'Can not create directories. Error: %s' % e
            return False

        # Populate tests
        with open('modules/%s/tests/init.pp' % self.service_name, 'w') as f:
            f.write('include ::%s\n' % self.service_name)

        with open('modules/%s/tests/Makefile' % self.service_name, 'w') as f:
            f.write('''# Test automator
MANIFESTS=$(wildcard *.pp)
OBJS=$(MANIFESTS:.pp=.po)
TESTS_DIR=$(dir $(CURDIR))
MODULE_DIR=$(TESTS_DIR:/=)
MODULES_DIR=$(dir $(MODULE_DIR))

all:    test

test:   $(OBJS)

%.po:   %.pp
\tpuppet parser validate $<
\tpuppet apply --noop --modulepath $(MODULES_DIR) $<
''')

        # Populate templates
        with open('modules/%s/templates/config.yaml.erb' % self.service_name, 'w') as f:
            f.write('# Generated by new_wmf_service.py.\n{}\n')

        # Populate manifests
        if self.service_node:
            with open('modules/%s/manifests/init.pp' % self.service_name, 'w') as f:
                f.write('''
# Class: %(name)s
#
# This class installs and configures %(name)s
#
# While only being a thin wrapper around service::node, this class exists to
# accomodate future %(name)s needs that are not suited for the service module
# classes as well as conform to a de-facto standard of having a module for every
# service
class %(name)s() {
    service::node { '%(name)s':
        port   => %(port)s,
        config => template('%(name)s/config.yaml.erb'),
    }
}
''' % {'name': self.service_name, 'port': self.port})

        # Restore cwd
        os.chdir(cwd)
        return True

    def create_puppet_role(self):
        # Keep cwd
        cwd = os.getcwd()
        os.chdir('..')

        # Populate role
        if self.service_node:
            with open('manifests/role/%s.pp' % self.service_name, 'w') as f:
                f.write('''
# Role class for %(name)s
class role::%(name)s {

    system::role { 'role::%(name)s':
        description => '%(description)s',
    }

    include ::%(name)s
}

''' % {'name': self.service_name, 'description': self.service_description})

        # Restore cwd
        os.chdir(cwd)
        return True

    def create_deployment_config(self):
        return False

    def assign_service_to_node(self):
        return False

    def setup_lvs(self):
        return False

    def setup_accounts(self):
        return False

    def setup_sudo_rights(self):
        return False

    def setup_restbase_entrypoint(self):
        return False

    def setup_varnish_entrypoint(self):
        return False


def question_user(answers):
    for q in QUESTIONS:
        if q['qname'] in answers and answers[q['qname']]:
            continue
        successful = False
        while not successful:
            answer = raw_input('%s? ' % q['qstring'])
            if q['validator'](answer):
                successful = True
        answers[q['qname']] = q['transformer'](answer)
    return answers


def main():
    # Handle arguments
    answers = handle_args()
    # Get answers to questions not provided by arguments
    answers = question_user(answers)
    s = Service(answers)
    if not s.create_puppet_module():
        print 'Bailing out'
        return False
    if not s.create_puppet_role():
        print 'Bailing out'
        return False


def handle_args():
    parser = argparse.ArgumentParser(
        description='shell helper for automating introduction of a new service')

    # Getting any answer to questions from arguments
    for q in QUESTIONS:
        parser.add_argument('--%s' % q['qname'],
                            help=q['qstring'],
                            action='store',
                            dest='%s' % q['qname'])
    parser.add_argument('-v', '--version', action='version', version='0.1beta1')
    args = parser.parse_args()
    return vars(args)

if __name__ == "__main__":
    main()
