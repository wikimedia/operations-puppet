# This rakefile is meant to run linters and tests
# You will need 'bundler' to install dependencies:
#
#  $ apt-get install bundler
#  $ bundle install
#
# Then run the linter using rake (a ruby build helper) inside the env set by
# bundler:
#
#   $ bundle exec rake puppetlint
#
# puppet-lint doc is at https://github.com/rodjek/puppet-lint
#
#
# Another target is spec, which runs unit/integration tests. You will need some
# more gems installed using bundler:
#
#   $ bundle install
#   $ bundle exec rake spec
#
# Continuous integration invokes 'bundle exec rake test'.
require 'English'
require 'git'
require 'puppet-syntax'
require 'puppet-syntax/tasks/puppet-syntax'
require 'rubocop/rake_task'
require 'rake/tasklib'
require 'rake/testtask'
require 'rake'
require 'puppet-lint/tasks/puppet-lint'


# Monkey-patch PuppetSyntax and its rake task
module PuppetSyntax
  @manifests_paths = ["**/*.pp"]
  @templates_paths = ["**/*.erb"]
  class << self
    attr_accessor :manifests_paths, :templates_paths
  end
end

class PuppetSyntax::RakeTask
  def filelist_manifests
    filelist(PuppetSyntax.manifests_paths)
  end

  def filelist_templates
    filelist(PuppetSyntax.templates_paths)
  end
end

class TaskGen < ::Rake::TaskLib

  def initialize(path)
    setup_tasks_list
    @changed_files = git_changed_in_head(path)
    @file_buckets = fill_file_buckets
  end

  def all_tasks
    TaskGen.class_variable_get(:@@tasks_list)
  end

  def tasks
    all_tasks.select{ |x| @file_buckets[x] }
  end

  private
  def setup_tasks_list
    TaskGen.class_variable_set(
      :@@tasks_list,
      [:puppet_lint, :typos, :syntax, :rubocop]
    )
  end

  def git_changed_in_head(path)
    g = Git.open(path)
    diff = g.diff('HEAD^')
    diff.name_status.select { |_, status| 'ACM'.include? status}.keys
  end

  def fill_file_buckets
    buckets = {}
    all_tasks.each do |task|
      method_name = "setup_#{task}"
      buckets[task] = send(method_name)
    end
    buckets
  end

  def puppet_changed_files
    @changed_files.select{ |x| File.fnmatch("*.pp", x) }
  end

  def filter_files_by(*globs)
    changed = FileList[@changed_files]
    changed.exclude(*PuppetSyntax.exclude_paths).select do |file|
      # If at least one glob pattern matches, the file is included.
      !globs.select{ |glob| File.fnmatch(glob, file)}.empty?
    end
  end

  def setup_puppet_lint
    changed = puppet_changed_files
    return false if changed.empty?
    # Reset puppet-lint tasks, define a new one
    Rake::Task[:lint].clear
    PuppetLint::RakeTask.new :puppet_lint do |config|
      config.fail_on_warnings = true  # be strict
      config.log_format = '%{path}:%{line} %{KIND} %{message} (%{check})'
      config.pattern = changed
    end
    true
  end

  def setup_typos
    return false if @changed_files.empty?
    # TODO: use some shell quoting library maybe?
    shell_files = @changed_files.map{ |x| "'#{x}'" }.join " "
    desc "Check common typos from /typos"
    task :typos do
      system("git grep -q -I -P -f typos -- #{shell_files}")
      case $CHILD_STATUS.exitstatus
      when 0
        fail "Typo found!"
      when 1
        puts "No typo found."
      else
        fail "Some error occured"
      end
    end
    true
  end

  def setup_syntax
    # Reset puppet-syntax tasks, define a new one
    Rake::Task[:syntax].clear

    # site.pp still uses an import statement for realm.pp (T154915)
    # We can think of activating this once we've moved to the future parser
    PuppetSyntax.fail_on_deprecation_notices = false
    if Puppet.version.to_f < 4.0
      PuppetSyntax.exclude_paths = [
        'modules/stdlib/types/*.pp',
        'modules/stdlib/types/compat/*.pp',
        'modules/stdlib/spec/fixtures/test/manifests/*.pp',
      ]
    end
    # Set up filelists
    PuppetSyntax.manifests_paths = puppet_changed_files
    PuppetSyntax.templates_paths = filter_files_by("**/templates/**/*.erb", "**/templates/**/*.epp")
    PuppetSyntax.hieradata_paths = filter_files_by("hieradata/**/*.yaml", "conftool-data/**/*.yaml")
    tasks = []
    unless PuppetSyntax.manifests_paths.empty?
      tasks << 'syntax:manifests'
    end
    unless PuppetSyntax.templates_paths.empty?
      tasks << 'syntax:templates'
    end
    unless PuppetSyntax.hieradata_paths.empty?
      tasks << 'syntax:hiera'
    end
    return false if tasks.empty?
    # Now re-set up the jobs by instantiating the class
    PuppetSyntax::RakeTask.new
    true
  end

  def setup_rubocop
    # TODO: use rubocop itself?
    ruby_files = filter_files_by("**/*.rb", "**/Rakefile")
    return false if ruby_files.empty?
    rubocop_task = RuboCop::RakeTask.new(:rubocop)
    rubocop_task.patterns = ruby_files
  end

end


t = TaskGen.new('.')

desc 'Run all actual tests in parallel for changes in HEAD'
multitask :test => t.tasks

# Puppet syntax checks
task :debug do
  puts t.tasks
end


desc 'Show the help'
task :help do
  puts "Puppet helper for operations/puppet.git

Welcome #{ENV['USER']} to WMFs wonderful rake helper to play with puppet.

---[Command line options]----------------------------------------------
`rake -T` : list available tasks
`rake -P` : shows tasks dependencies

---[Available rake tasks]----------------------------------------------"

  # Show our tasks list.
  system "rake -T"

  puts "-----------------------------------------------------------------------"
end
