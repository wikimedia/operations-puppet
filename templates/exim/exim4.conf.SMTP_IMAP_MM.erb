#####################################################################
### THIS FILE IS MANAGED BY PUPPET
### puppet:///templates/exim/exim4.conf.SMTP_IMAP_MM.erb
#####################################################################

##########
# Macros #
##########

CONFDIR=/etc/exim4
WIKI_INTERFACE=<; 208.80.152.133 ; 208.80.154.91 ; 2620:0:861:3:208:80:154:91

<% if enable_imap_delivery == true then -%>
USERDB=/var/vmaildb/user.db
VMAIL=/var/vmail
DELIVER=/usr/lib/dovecot/deliver
NOT_LOCALLY_SUBMITTED=${if !match{$received_protocol}{\Nsmtpsa$\N}}

<% end -%>
<% if enable_mailman == true then -%>
# Mailman
MAILMAN_HOME = /usr/lib/mailman
MAILMAN_LISTS_HOME = /var/lib/mailman
MAILMAN_WRAP = MAILMAN_HOME/mail/mailman
MAILMAN_UID = list
MAILMAN_GID = list

<% end -%>
<% if enable_otrs_server == true then -%>
# OTRS
OTRS_POSTMASTER=/opt/otrs/bin/otrs.PostMaster.pl
OTRS_HOME=/var/lib/otrs
OTRS_USER=otrs
OTRS_GROUP=www-data

<% end -%>
###############################
# Main configuration settings #
###############################

<% if enable_mail_relay == "primary" or enable_otrs_server == true then -%>
# MySQL lookups (OTRS)
hide mysql_servers =  m2-master.eqiad.wmnet/otrs/exim/<%= scope.lookupvar('exim::smtp::otrs_mysql_password') %> : m2-slave.eqiad.wmnet/otrs/exim/<%= scope.lookupvar('exim::smtp::otrs_mysql_password') %>
<% end -%>

<% if enable_mail_relay == "primary" then -%>
# LDAP lookups (Office)
ldap_default_servers = sanger.wikimedia.org
LDAPPASSWORD=<%= scope.lookupvar('exim::smtp::smtp_ldap_password') %>
<% end -%>

domainlist system_domains = @
domainlist local_domains = <%= local_domains.join(" : ") %>
domainlist wikimedia_domains = lsearch;CONFDIR/wikimedia_domains
<% if enable_mail_relay == "secondary" then -%>
domainlist secondary_domains = @mx_secondary/ignore=127.0.0.1
<% end -%>
<% if enable_mail_relay != false %>
domainlist relay_domains = +wikimedia_domains
<% end -%>

# a list of domains to always respond defer; used for emergencies or planned downtimes
domainlist defer_domains = lsearch;CONFDIR/defer_domains

# Standard lists
domainlist legacy_mailman_domains = wikimedia.org : wikipedia.org : mail.wikimedia.org : mail.wikipedia.org
domainlist mailman_domains = lists.wikimedia.org
domainlist rt_domains = rt.wikimedia.org
domainlist donate_domains = donate.wikimedia.org
domainlist spamassassin_domains = *

hostlist wikimedia_nets = <; <%= scope.lookupvar('network::constants::all_networks').join(" ; ") %>
hostlist relay_from_hosts = <; @[] ; 127.0.0.1 ; ::1 ; <% if enable_mail_relay != false -%><%= scope.lookupvar('network::constants::external_networks').join(" ; ") %>; 10.0.0.0/8<% end %>
<% if enable_mail_relay == "secondary" then -%>
hostlist primary_mx = <; <%= scope.lookupvar('exim::constants::primary_mx').join(" ; ") %>
<% end -%>
<% if enable_otrs_server == true then -%>
hostlist otrs_mail_from_hosts = mchenry.wikimedia.org
<% end -%>
<% if enable_imap_delivery == true then -%>

# Interfaces
daemon_smtp_ports = smtp : ssmtp
<% elsif enable_otrs_server == true then -%>

# Interfaces
daemon_smtp_ports = smtp
<% end -%>

# Administration
log_selector = +address_rewrite +all_parents +delivery_size +deliver_time +incoming_interface +incoming_port +smtp_confirmation +smtp_protocol_error +smtp_syntax_error +tls_cipher +tls_peerdn
<% if enable_otrs_server == false then -%>
message_logs = false
<% end -%>

# Policy control
acl_smtp_connect = acl_check_connect
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data

<% if enable_mail_relay != false or enable_otrs_server == true then -%>
helo_try_verify_hosts = *
<% end -%>

<% if rt_relay == true or enable_otrs_server == true then -%>
# Allow RT, OTRS to use any sender address
untrusted_set_sender = *
local_from_check = false
<% end -%>

system_filter = CONFDIR/system_filter

# Resource control
check_spool_space = 50M
smtp_reserve_hosts = <; 127.0.0.1 ; ::1 ; +wikimedia_nets
smtp_accept_queue_per_connection = 500

deliver_queue_load_max = 800.0
queue_only_load = 100.0
remote_max_parallel = 500

smtp_connect_backlog = 128
smtp_receive_timeout = 1m
smtp_accept_max = 4000
smtp_accept_max_per_host = ${if match_ip{$sender_host_address}{+wikimedia_nets}{50}{5}}
smtp_accept_reserve = 100

# Lookups
host_lookup = *
rfc1413_hosts =
<% if enable_spamassassin == true then -%>

# Content filtering
spamd_address = 127.0.0.1 783
<% end %>
<% if enable_clamav == true then -%>

# Malware scanning
av_scanner = clamd:/var/run/clamav/clamd.ctl
<% end %>

<% if enable_imap_delivery == true then -%>
# TLS
tls_certificate = /etc/ssl/certs/wikimedia.org.pem
tls_privatekey = /etc/ssl/private/wikimedia.org.key
tls_advertise_hosts = *
tls_on_connect_ports = 465
<% end %>

# Other
never_users = root : daemon : bin
ignore_bounce_errors_after = 0h

# Hold mail for these domains (e.g. for testing/debugging)
hold_domains = <%= hold_domains.join(" : ") %>

# force Gmail over IPv4 due to reports of bad spam reputation over IPv6
dns_ipv4_lookup = gmail-smtp-in.l.google.com : aspmx.l.google.com

###############################
# Access Control Lists (ACLs) #
###############################

begin acl

acl_check_rcpt:

<% if enable_mail_relay != false then -%>
	# If there have been ~4 times as many previous RCPT rejects than
	# accepts, drop the connection

	drop message = Too many ($rcpt_fail_count) rejected recipients, good bye
		hosts = ! +wikimedia_nets
		condition = ${if >={$rcpt_fail_count}{${eval:4*($recipients_count+1)}}}
<% end -%>

	# Accept if the source is local SMTP (a pipe)

	accept hosts = :

	# Deny if the local part contains @, %, /, | or !, or starts with a dot

	deny local_parts = ^.*[@%!/|] : ^\\.

	# Accept relaying from networks we control. Note: no address verification
	# is done at this point, which is good for mail submission, but may render
	# recipient callout verification by affected hosts useless.

<% if enable_otrs_server == true then -%>
	accept hosts = +otrs_mail_from_hosts : +relay_from_hosts
<% else -%>
	accept domains = ! +local_domains
		hosts = +relay_from_hosts
		control = submission/sender_retain
<% end -%>

<% if enable_mail_submission == true then -%>
# Mail submissions from other hosts must be from SMTP authenticated users

	accept authenticated = *
		encrypted = *
		control = submission/sender_retain

# We only accept mail from our own mail relays, on port 25 only

	require message = Use TLS and SMTP authentication
		hosts = +wikimedia_nets
		message = This port is restricted to authenticated and encrypted mail submissions
		condition = ${if eq{$interface_port}{25}}
<% end -%>

<% if enable_otrs_server == true then -%>
	# Require recipient domain to be local

	require message = Relay not permitted
		domains = +local_domains
		set acl_m_relayed = yes
<% else -%>
	# Require recipient domain to be local, or a domain we relay for

	require message = Relay not permitted
		domains = +local_domains : +relay_domains <% if enable_mail_relay == "secondary" then -%>: +secondary_domains<% end %>
		set acl_m_relayed = yes

	# { recipient domain is under our administrative control }

	# use this only for emergencies or planned downtimes
	defer	message = Administratively set to defer
		domains = +defer_domains

	# Accept mail for postmaster without further policy checking,
	# for compliance with the RFCs

	accept local_parts = postmaster
<% end -%>

	# Verify the recipient address for local domains, or require the
	# recipient domain to exist for remote domains

	require verify = recipient

<% if enable_mail_relay != false then -%>
	# If the destination domain is a domain we relay for,
	# check if the local part exists at the destination,
	# reject if it doesn't.
	# Accept if the destination cannot be reached within 30s.

	deny domains = +relay_domains <% if enable_mail_relay == "secondary" then -%>: +secondary_domains<% end %>
		! verify = recipient/callout=10s,maxwait=30s,defer_ok
<% end -%>

	# Mail can be safely accepted here, but we may want to do more
	# rfc compliance checking and spam filtering.
	<% if enable_mail_relay != false then -%>

	# Check whether the sender address domain exists

	require verify = sender

<% end -%>
	accept
<% if enable_mail_relay != false then -%>
		set acl_m2 = ${if eq{$local_part@$domain}{wiki@wikimedia.org}{skip_spamd}{}}
<% end -%>

acl_check_connect:
<% if mediawiki_relay == true then -%>
	# Deny external connections to the internal bulk mail submission
	# interface

	deny condition = ${if match_ip{$interface_address}{WIKI_INTERFACE}{true}{false}}
		! hosts = +wikimedia_nets

<% end -%>
<% if enable_external_mail == false then -%>
	# We only accept mail from our own mail relays
	require message = This server does not accept external mail
		hosts = <; 127.0.0.0/8 ; ::1 ; +wikimedia_nets
<% end -%>
	accept

acl_check_data:
<% if ( enable_spamassassin == true ) then -%>
<% if ( enable_otrs_server == true ) then -%>
	# skip spam-check for locally-submitted messages
	accept hosts = +relay_from_hosts
		set acl_m0 = trusted relay

	# skip if message is too large (>4M)
	accept condition = ${if >{$message_size}{4M}}
		set acl_m0 = n/a
		set acl_m1 = skipped, message too large

	# add spam headers...
	warn spam = nonexistent:true
		set acl_m0 = $spam_score ($spam_bar)
		set acl_m1 = $spam_report
		set acl_m3 = $spam_score_int

	# silently drop spam at high scores (> 12)
	discard log_message = spam detected ($spam_score)
		condition = ${if >{$spam_score_int}{120}{1}{0}}
<% else -%>
	# Let's trust local senders (Mailman) to not send out spam
	accept hosts = +wikimedia_nets
		set acl_m0 = trusted relay

	# Only run through SpamAssassin if requested for this domain and
	# the message is not too large (Mailman's default moderation
	# threshold of 40 KB)
	accept condition = ${if >{$message_size}{400K}}

	# Skip if so requested
	accept condition = ${if eq{$acl_m2}{skip_spamd}}

	# Add spam headers if score >= 1
	warn spam = nonexistent:true
		condition = ${if >{$spam_score_int}{10}{1}{0}}
		set acl_m0 = $spam_score ($spam_bar)
		set acl_m1 = $spam_report

	# Reject spam at high scores (> 12)
	deny message = This message scored $spam_score spam points.
		spam = nonexistent/defer_ok
		condition = ${if >{$spam_score_int}{120}{1}{0}}
<% end -%>
<% end -%>
<% if enable_clamav == true then -%>

	# silently discard messages with malware attached
	discard log_message = malware detected ($malware_name)
		demime = *
		malware = *
<% end -%>

	accept

###########
# Routers #
###########

begin routers

<% if enable_mailman == true then -%>
list_outbound:
	driver = dnslookup
	domains = ! +local_domains
	senders = *@lists.wikimedia.org
	condition = ${if match_ip{$sender_host_address}{@[]}}
	transport = list_smtp
	no_verify

<% end -%>
<% if enable_mail_relay == "secondary" then -%>
# Route relay domains only if the higher prio MXes are in the allowed list
secondary:
	driver = dnslookup
	domains = ! +relay_domains : +secondary_domains
	transport = remote_smtp
	ignore_target_hosts = ! +primary_mx
	cannot_route_message = Primary MX(s) for $domain not in the allowed list
	no_more

<% end %>
<% if mediawiki_relay == true then -%>
# Route mail generated by MediaWiki differently
wiki_mail:
	driver = dnslookup
	domains = ! +local_domains
	condition = ${if and{{match_ip{$interface_address}{WIKI_INTERFACE}}{eqi{$header_X-Mailer:}{MediaWiki mailer}}}}
	errors_to = wiki@wikimedia.org
	transport = bulk_smtp
	ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; 10/8 ; 172.16/12 ; 192.168/16
	no_verify

<% end -%>
<% if enable_mail_relay != false then -%>
# Send donate.wikimedia.org mail to Fundraising CiviCRM server
donate:
	driver = manualroute
	domains = +donate_domains
	route_list = * aluminium.wikimedia.org byname
	transport = remote_smtp

# Route non-local domains (including +relay_domains) via DNS MX and A records
dnslookup:
	driver = dnslookup
	domains = ! +local_domains
	transport = ${if eq {$acl_m_relayed}{yes}{remote_smtp}{remote_smtp_signed}}
	ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; 10/8 ; 172.16/12 ; 192.168/16
	cannot_route_message = Cannot route to remote domain $domain
	no_more

eat:
	driver = redirect
	domains = +local_domains
	local_parts = no-reply-notifications
	data = :blackhole:
<% end -%>

# Use the system aliasfile /etc/aliases for system domains

system_aliases:
	driver = redirect
	domains = +system_domains
	data = ${lookup{$local_part}lsearch{/etc/aliases}}
	pipe_transport = address_pipe
	allow_fail
	allow_defer
	forbid_file

<% if rt_relay == true then -%>
# Mail destined for RT

# This router checks whether the local part consists of solely digits,
# and assumes this is the ticket number of an existing ticket if this is
# the case. It rewrites the address to the general queue, and puts the
# ticket nr in $address_data, where the rt_pipe transport can access it.

rt_ticket:
	driver = redirect
	domains = +rt_domains
	local_part_suffix = -comment
	local_part_suffix_optional
	condition = ${if match{$local_part}{\N^\d+$\N}{yes}{no}}
	address_data = EXTENSION=$local_part
	data = general$local_part_suffix@$domain
	redirect_router = rt
	no_verify

rt:
	driver = accept
	domains = +rt_domains
	local_part_suffix = -comment
	local_part_suffix_optional
	transport = rt_pipe

<% end -%>
<% if enable_mailman == true then -%>
# Mailman list handling.

list_aliases:
	driver = redirect
	domains = +local_domains
	require_files = CONFDIR/aliases/$domain
	data = ${lookup{$local_part}lsearch*{CONFDIR/aliases/$domain}}
	qualify_preserve_domain
	allow_fail
	allow_defer
	forbid_file
	forbid_pipe
	include_directory = CONFDIR

# Test the mailing list address without suffix
# first, as a mailing list like wikifi-admin is a valid list name.

list:
	driver = accept
	domains = +mailman_domains
	require_files = MAILMAN_LISTS_HOME/lists/$local_part/config.pck
	transport = list

list_suffix:
	driver = accept
	domains = +mailman_domains
	require_files = MAILMAN_LISTS_HOME/lists/$local_part/config.pck
	local_part_suffix = -bounces : -bounces+* : \
				-confirm+* : -join : -leave : \
				-owner : -request : -admin : \
				-subscribe : -unsubscribe
	transport = list
<% end -%>
<% if enable_mail_relay == "primary" then -%>
# Use alias files /etc/exim4/aliases/$domain for domains like
# wikimedia.org, wikipedia.org, wiktionary.org etc.

aliases:
	driver = redirect
	domains = +local_domains
	require_files = CONFDIR/aliases/$domain
	data = ${lookup{$local_part}lsearch*{CONFDIR/aliases/$domain}}
	qualify_preserve_domain
	allow_fail
	allow_defer
	forbid_file
	include_directory = CONFDIR
	pipe_transport = address_pipe

# Alias old mailing list addresses to @lists.wikimedia.org on lily

legacy_mailing_lists:
	driver = redirect
	domains = +legacy_mailman_domains
	data = $local_part$local_part_suffix@lists.wikimedia.org
	local_parts = lsearch;CONFDIR/legacy_mailing_lists
	local_part_suffix = -bounces : -bounces+* : \
				-confirm+* : -join : -leave : \
				-owner : -request : -admin : \
				-subscribe : -unsubscribe
	local_part_suffix_optional

# LDAP accounts
ldap_account:
	driver = manualroute
	domains = wikimedia.org
	condition = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=people,dc=corp,dc=wikimedia,dc=org?mail?sub?(&(objectClass=inetOrgPerson)(mail=${quote_ldap:$local_part}@$domain)(x121Address=1))} \
			{true}fail}
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
route_list = *  aspmx.l.google.com

ldap_group:
	driver = manualroute
	domains = wikimedia.org
	condition = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=groups,dc=corp,dc=wikimedia,dc=org?businessCategory?sub?(businessCategory=${quote_ldap:$local_part}@$domain)} \
			{true}fail}
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
	route_list = *  aspmx.l.google.com

ldap_alias:
	driver = redirect
	domains = wikimedia.org
	data = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=people,dc=corp,dc=wikimedia,dc=org?mail?sub?(&(objectClass=inetOrgPerson)(initials=${quote_ldap:$local_part}@$domain)(x121Address=1))} \
			{$value}fail}

# Send mail for IMAP accounts to sanger
imap:
	driver = manualroute
	domains = wikimedia.org
	local_parts = lsearch;CONFDIR/imap_accounts
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
	route_list = *  sanger.wikimedia.org

# Send RT mails to the RT server
rt:
	driver = manualroute
	domains = +rt_domains
	route_list = * magnesium.wikimedia.org byname
	transport = remote_smtp

# Query the OTRS MySQL server(s) for the existence of the queue address
# $local_part@$domain, and manually route to the OTRS server if
# successful.

# OTRS down, defer mail without checking the db and slowing things down -- mark 20080622
#otrs_down:
#	driver = redirect
#	allow_defer
#	data = :defer: Cannot check existence of this address right now

otrs:
	driver = manualroute
	domains = +local_domains
	condition = ${lookup mysql{SELECT value0 FROM system_address WHERE value0='${quote_mysql:$local_part@$domain}'}{true}fail}
	route_list = *  iodine.wikimedia.org  byname
	transport = remote_smtp
<% end %>
<% if enable_imap_delivery == true then -%>
# Run a custom user filter, e.g. to sort mail into subfolders
# By default Exim filter CONFDIR/default_user_filter is run,
# which sorts mail classified spam into the Junk folder

user_filter:
	driver = redirect
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	router_home_directory = VMAIL/$domain/$local_part
	address_data = ${lookup sqlite{USERDB \
		SELECT id, filter NOTNULL AS hasfilter \
		FROM account \
		WHERE localpart='${quote_sqlite:$local_part}' \
			AND domain='${quote_sqlite:$domain}' \
	 		AND active='1'}{$value}fail}
	data = ${if eq{${extract{hasfilter}{$address_data}}}{1}{ \
		${lookup sqlite{USERDB \
		SELECT filter \
		FROM account \
		WHERE id='${quote_sqlite:${extract{id}{$address_data}}}'}}} \
		{${readfile{CONFDIR/default_user_filter}}}}
	allow_filter
	forbid_filter_dlfunc
	forbid_filter_existstest
	forbid_filter_logwrite
	forbid_filter_lookup
	forbid_filter_perl
	forbid_filter_readfile
	forbid_filter_readsocket
	forbid_filter_run
	forbid_include
	forbid_pipe
	user = vmail
	group = vmail
	directory_transport = maildir_delivery
	reply_transport = reply_transport
	no_verify

# Delivery to a Maildir mail box.
local_user:
	driver = accept
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	local_part_suffix = +*
	local_part_suffix_optional
	address_data = ${lookup sqlite{USERDB \
		SELECT id, quota \
		FROM account \
		WHERE localpart='${quote_sqlite:$local_part}' \
			AND domain='${quote_sqlite:$domain}' \
			AND active='1'}{$value}fail}
	transport = maildir_delivery
	transport_home_directory = VMAIL/$domain/$local_part
	transport_current_directory = VMAIL

# Bounce/auto-reply messages for users that have left
user_left:
	driver = accept
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	require_files = CONFDIR/userleft/$domain/$local_part
	transport = left_message

# Send all mail not destined for the local machine via a set of
# mail relays ("smart hosts")

<% end %>
<% if enable_mail_relay != false then -%>

# Redirect postmaster@$domain if it hasn't been accepted before
postmaster:
	driver = redirect
	domains = +local_domains
	local_parts = postmaster
	data = postmaster@$primary_hostname
<% end %>
<% if enable_mailman == true then -%>
	cannot_route_message = Mailing list $local_part does not exist.
<% elsif enable_mail_relay != false then -%>
	cannot_route_message = Address $local_part@$domain does not exist
<% end %>
<% if enable_otrs_server == true then -%>
otrs:
	driver = accept
	condition = ${lookup mysql{SELECT value0 FROM system_address WHERE value0='${quote_mysql:$local_part@$domain}'}{true}fail}
	transport = otrs
<% end %>

<% if !smart_route_list.empty? then -%>
smart_route:
	driver = manualroute
	transport = remote_smtp
	route_list = *  <%= smart_route_list.join(":") %>
<% end %>

##############
# Transports #
##############

begin transports

# Generic remote SMTP transport

remote_smtp:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
<% if !outbound_ips.empty? then -%>
	interface = <; <%= outbound_ips.join(" ; ") %>
<% end -%>

remote_smtp_signed:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
	dkim_domain = wikimedia.org
	dkim_selector = wikimedia
	dkim_private_key = ${if exists{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{0}}
	dkim_canon = relaxed
<% if !outbound_ips.empty? then -%>
	interface = <; <%= outbound_ips.join(" ; ") %>
<% end -%>

<% if enable_mailman == true -%>
list_smtp:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
	interface = <; <%= list_outbound_ips.join(" ; ") %>
	helo_data = lists.wikimedia.org
	dkim_domain = lists.wikimedia.org
	dkim_selector = wikimedia
	dkim_private_key = ${if exists{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{0}}
	dkim_canon = relaxed
<% end -%>

<% if mediawiki_relay == true -%>
# Transport for sending out automated bulk (wiki) mail
# DKIM signed with wikimedia.org irrespective of actual sender domain
# but using a separate selector that only allows "wiki" as the local part
bulk_smtp:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
	interface = WIKI_INTERFACE
	helo_data = ${lookup dnsdb{ptr=$sending_ip_address}{$value}{wiki-mail.wikimedia.org}}
	dkim_domain = wikimedia.org
	dkim_selector = wiki-mail
	dkim_private_key = ${if exists{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{/etc/exim4/dkim/${dkim_domain}-${dkim_selector}.key}{0}}
	dkim_canon = relaxed
<% end -%>

# Generic pipe local delivery transport (for use by alias/forward files)

address_pipe:
	driver = pipe
	return_output

<% if rt_relay == true then -%>
# RT transport
rt_pipe:
	driver = pipe
	command = /usr/bin/rt-mailgate --queue $local_part \
		--action "${if eq{$local_part_suffix}{-comment}{comment}{correspond}}" \
		--extension ticket --url https://rt.wikimedia.org
	environment = $address_data
	user = mail
	group = mail
	return_fail_output

<% end -%>
<% if enable_otrs_server == true then -%>
# OTRS pipe transport

otrs:
	driver = pipe
	command = OTRS_POSTMASTER
	current_directory = OTRS_HOME
	home_directory = OTRS_HOME
	user = OTRS_USER
	group = OTRS_GROUP
	freeze_exec_fail
	log_fail_output
	timeout = 1m
	timeout_defer

<% end -%>
<% if enable_mailman == true then -%>
# Mailman pipe transport
# Rewrite body headers of old mailing list addresses to new ones

list:
	driver = pipe
	command = MAILMAN_WRAP \
		'${if def:local_part_suffix \
			{${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}} \
			{post}}' \
		$local_part
	current_directory = MAILMAN_LISTS_HOME
	home_directory = MAILMAN_LISTS_HOME
	user = MAILMAN_UID
	group = MAILMAN_GID
	#headers_rewrite = \N^.*@(mail\.)?wiki[mp]edia\.org$\N "${if exists{MAILMAN_LISTS_HOME/lists/$local_part/config.pck}{$local_part@lists.wikimedia.org}fail}" ct

<% end %>
<% if enable_imap_delivery == true then -%>
# Delivery via Dovecot's "deliver" LDA. The advantage over using Exim's
# internal Maildir appendfile transport is that it can immediately update
# Dovecot's internal indexes for better performance.

dovecot_delivery:
	driver = pipe
	command = DELIVER -m ${extract{mailbox}{$address_data}{$value}{INBOX}}
	log_output
	return_fail_output
	message_prefix =
	message_suffix =
	delivery_date_add
	envelope_to_add
	return_path_add
	user = vmail
	group = vmail

# Exim appendfile transport for Maildir delivery

maildir_delivery:
	driver = appendfile
	maildir_format
	directory = ${if def:address_file{$address_file}{$home}}
	create_directory
	create_file = belowhome
	delivery_date_add
	envelope_to_add
	return_path_add
	user = vmail
	group = vmail

	# Quota support
	quota = ${if !eq{$received_protocol}{local}{${extract{quota}{$address_data}{${value}K}{0}}}}
	quota_is_inclusive = false
	quota_warn_threshold = 100%
	quota_warn_message = ${expand:${readfile{CONFDIR/quota_warn_message}}}
	maildir_use_size_file
	maildir_quota_directory_regex = ^(?:cur|new|\.(?!Trash).*)
	maildir_tag = ,S=$message_size

# Autoreply bounce transport for users that have left the organization

left_message:
	driver = autoreply
	file = CONFDIR/userleft/$domain/$local_part
	file_expand
	return_message
	from = Wikimedia Foundation <postmaster@wikimedia.org>
	to = $sender_address
	reply_to = office@wikimedia.org
	subject = User ${quote_local_part:$local_part}@$domain has left the organization: returning message to sender

reply_transport:
	driver = autoreply
<% end %>
<% if enable_mail_submission == true then -%>
##################
# Authenticators #
##################

begin authenticators

# PLAIN authenticator
# Expects the password field to contain a "LDAP format" hash. Only
# (unsalted) {md5}, {sha1}, {crypt} and {crypt16} are supported.

plain:
	driver = plaintext
	public_name = PLAIN
	server_prompts = :
	server_condition = ${lookup sqlite{USERDB \
		SELECT password \
		FROM account \
		WHERE localpart||'@'||domain='${quote_sqlite:$auth2}' \
			AND active='1'} \
		{${if crypteq{$auth3}{$value}}}{false}}
	server_set_id = $auth2
	server_advertise_condition = ${if def:tls_cipher}
<% end %>
###############
# Retry rules #
###############

begin retry

<% if mediawiki_relay == true then -%>
*	*	senders=wiki@wikimedia.org	F,1h,15m; G,8h,1h,1.5
<% end -%>
*	*	F,2h,15m; G,16h,1h,1.5; F,4d,6h
<% if ( enable_mail_relay != false ) -%>

#################
# Rewrite rules #
#################

begin rewrite

<% end %>
<% if rt_relay == true then -%>
#################
# Rewrite rules #
#################

begin rewrite

# Rewrite RT
www-data@$primary_hostname      general@rt.wikimedia.org        Fq

<% end -%>
<% if enable_mailman == true then -%>
\N^.*@(mail\.)?wiki[mp]edia\.org$\N "${if exists{MAILMAN_LISTS_HOME/lists/$local_part/config.pck}{$local_part@lists.wikimedia.org}fail}" ct
<% end %>
<% if ( enable_mail_relay != false ) -%>
# Rewrite the envelope From for mails from internal servers in *.pmtpa.wmnet,
# as they are usually rejected by sender domain address verification.
*@*.pmtpa.wmnet		root@wikimedia.org	F
*@*.eqiad.wmnet		root@wikimedia.org	F
*@*.codfw.wmnet		root@wikimedia.org	F
*@*.esams.wmnet		root@wikimedia.org	F
*@*.ulsfo.wmnet		root@wikimedia.org	F
#*@*.wikimedia.org	root@wikimedia.org	F
<% end -%>
