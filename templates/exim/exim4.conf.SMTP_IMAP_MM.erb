#####################################################################
### THIS FILE IS MANAGED BY PUPPET 
### puppet:///templates/exim/exim4.conf.SMTP_IMAP_MM.erb
#####################################################################

##########
# Macros #
##########

# (Not all will be used)
CONFDIR=/etc/exim4
WIKI_INTERFACE=<; 208.80.152.133 ; 91.198.174.5 ; 2620:0:862:1::25:1 
USERDB=/var/vmaildb/user.db
VMAIL=/var/vmail
DELIVER=/usr/lib/dovecot/deliver
NOT_LOCALLY_SUBMITTED=${if !match{$received_protocol}{\Nsmtpsa$\N}}

# Mailman
MAILMAN_HOME = /usr/lib/mailman
MAILMAN_LISTS_HOME = /var/lib/mailman
MAILMAN_WRAP = MAILMAN_HOME/mail/mailman
MAILMAN_UID = list
MAILMAN_GID = list

###############################
# Main configuration settings #
###############################

<% if scope.lookupvar('exim::roled::enable_mail_relay') == "primary" then -%>
# MySQL lookups (OTRS)
hide mysql_servers =  db48.pmtpa.wmnet/otrs/exim/<%= scope.lookupvar('exim::smtp::otrs_mysql_password') %> : db49.pmtpa.wmnet/otrs/exim/<%= scope.lookupvar('exim::smtp::otrs_mysql_password') %>

# LDAP lookups (Office)
ldap_default_servers = sanger.wikimedia.org
LDAPPASSWORD=<%= scope.lookupvar('exim::smtp::smtp_ldap_password') %>
<% end -%>

domainlist system_domains = @
domainlist local_domains = <%= scope.lookupvar('exim::roled::local_domains').join(" : ") %>
<% if scope.lookupvar('exim::roled::enable_mail_relay') == "secondary" then -%>
domainlist secondary_domains = @mx_secondary/ignore=127.0.0.1
<% end -%>
<%if scope.lookupvar('exim::roled::enable_mail_relay') != "false "%>
domainlist relay_domains = lsearch;CONFDIR/relay_domains
<% end -%>

# Standard lists
domainlist mx_primary = @mx_primary/ignore=127.0.0.1
domainlist legacy_mailman_domains = wikimedia.org : wikipedia.org : mail.wikimedia.org : mail.wikipedia.org
domainlist mailman_domains = lists.wikimedia.org
domainlist rt_domains = rt.wikimedia.org
domainlist spamassassin_domains = *

hostlist wikimedia_nets = <; <%= scope.lookupvar('network::constants::all_networks').join(" ; ") %>
hostlist relay_from_hosts = <; @[] ; 127.0.0.1 ; ::1 ; <% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" -%><%= scope.lookupvar('network::constants::external_networks').join(" ; ") %>; 10.0.0.0/8<% end %>
# Relay @mx_secondary domains only to these hosts
hostlist primary_mx = <; <%= scope.lookupvar('exim::constants::primary_mx').join(" ; ") %>


<% if scope.lookupvar('exim::roled::enable_imap_delivery') == "true" then -%>
# Interfaces
daemon_smtp_ports = smtp : ssmtp
<% end -%>

# Administration
log_selector = +address_rewrite +all_parents +delivery_size +deliver_time +incoming_interface +incoming_port +smtp_confirmation +smtp_protocol_error +smtp_syntax_error +tls_cipher +tls_peerdn
message_logs = false

# Policy control
acl_smtp_connect = acl_check_connect
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data

<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
helo_try_verify_hosts = *
<% end -%>

system_filter = CONFDIR/system_filter

# Resource control
check_spool_space = 50M
smtp_reserve_hosts = <; 127.0.0.1 ; ::1 ; +wikimedia_nets
smtp_accept_queue_per_connection = 500

deliver_queue_load_max = 800.0
queue_only_load = 100.0
remote_max_parallel = 100

smtp_connect_backlog = 128
smtp_receive_timeout = 1m
smtp_accept_max = 4000
smtp_accept_max_per_host = ${if match_ip{$sender_host_address}{+wikimedia_nets}{50}{5}}
smtp_accept_reserve = 100

# Lookups
host_lookup = *
rfc1413_hosts =
<% if scope.lookupvar('exim::roled::enable_spamassassin') == "true" then -%>

# Content filtering
spamd_address = 127.0.0.1 783
<% end %>
<% if scope.lookupvar('exim::roled::enable_imap_delivery') == "true" then -%>
# TLS
tls_certificate = /etc/ssl/certs/wikimedia.org.pem
tls_privatekey = /etc/ssl/private/wikimedia.org.key
tls_advertise_hosts = *
tls_on_connect_ports = 465
<% end %>

# Other
never_users = root : daemon : bin
ignore_bounce_errors_after = 0h

# Hold mail for these domains (e.g. for testing/debugging)
hold_domains = <%= scope.lookupvar('exim::roled::hold_domains').join(" : ") %>

###############################
# Access Control Lists (ACLs) #
###############################

begin acl

acl_check_rcpt:

<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
	# If there have been ~4 times as many previous RCPT rejects than
	# accepts, drop the connection

	drop message = Too many ($rcpt_fail_count) rejected recipients, good bye
		hosts = ! +wikimedia_nets
		condition = ${if >={$rcpt_fail_count}{${eval:4*($recipients_count+1)}}}
<% end -%>

	# Accept if the source is local SMTP (a pipe)

	accept hosts = :

	# Deny if the local part contains @, %, /, | or !, or starts with a dot

	deny local_parts = ^.*[@%!/|] : ^\\.

	# Accept relaying from networks we control. Note: no address verification
	# is done at this point, which is good for mail submission, but may render
	# recipient callout verification by affected hosts useless.

	accept hosts = +relay_from_hosts
		control = submission/sender_retain

<% if scope.lookupvar('exim::roled::enable_mail_submission') == "true" then -%>
# Mail submissions from other hosts must be from SMTP authenticated users

	accept authenticated = *
		encrypted = *
		control = submission/sender_retain

# We only accept mail from our own mail relays, on port 25 only

	require message = Use TLS and SMTP authentication
		hosts = +wikimedia_nets
		message = This port is restricted to authenticated and encrypted mail submissions
		condition = ${if eq{$interface_port}{25}}
<% end -%>
	# Require recipient domain to be local, or a domain we relay for

	require message = Relay not permitted
		domains = +local_domains : +relay_domains <% if scope.lookupvar('exim::roled::enable_mail_relay') == "secondary" then -%>: +secondary_domains<% end %>

	# { recipient domain is under our administrative control }

	# Accept mail for postmaster without further policy checking,
	# for compliance with the RFCs

	accept local_parts = postmaster

	# Verify the recipient address for local domains, or require the
	# recipient domain to exist for remote domains

	require verify = recipient

<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
	# If the destination domain is a domain we relay for,
	# check if the local part exists at the destination,
	# reject if it doesn't.
	# Accept if the destination cannot be reached within 30s.

	deny domains = +relay_domains <% if scope.lookupvar('exim::roled::enable_mail_relay') == "secondary" then -%>: +secondary_domains<% end %>
		! verify = recipient/callout=10s,maxwait=30s,defer_ok
<% end -%>

	# Mail can be safely accepted here, but we may want to do more
	# rfc compliance checking and spam filtering.
	<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>

	# Check whether the sender address domain exists

	require verify = sender

<% end -%>
	accept
<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
		set acl_m2 = ${if eq{$local_part@$domain}{wiki@wikimedia.org}{skip_spamd}{}}
<% end -%>

acl_check_connect:
<% if scope.lookupvar('exim::roled::enable_mediawiki_relay') != "true" then -%>
	# Deny external connections to the internal bulk mail submission
	# interface

	deny condition = ${if match_ip{$interface_address}{WIKI_INTERFACE}{true}{false}}
		! hosts = +wikimedia_nets

<% end -%>
	accept

acl_check_data:
<% if ( scope.lookupvar('exim::roled::enable_spamassassin') == "true" ) then -%>
	# Let's trust local senders (Mailman) to not send out spam
	accept hosts = +wikimedia_nets
		set acl_m0 = trusted relay

	# Run through spamassassin
	require acl = spamassassin
<% end -%>
	accept

<% if ( scope.lookupvar('exim::roled::enable_spamassassin') == "true" ) then -%>
spamassassin:
	# Only run through SpamAssassin if requested for this domain and
	# the message is not too large (Mailman's default moderation
	# threshold of 40 KB
	accept condition = ${if >{$message_size}{400K}}

	# Skip if so requested
	accept condition = ${if eq{$acl_m2}{skip_spamd}}

	# Add spam headers if score >= 1
	warn spam = nonexistent:true
		condition = ${if >{$spam_score_int}{10}{1}{0}}
		set acl_m0 = $spam_score ($spam_bar)
		set acl_m1 = $spam_report

	# Reject spam at high scores (> 12)
	deny message = This message scored $spam_score spam points.
		spam = nonexistent/defer_ok
		condition = ${if >{$spam_score_int}{120}{1}{0}}

	accept
<% end -%>

###########
# Routers #
###########

begin routers

<% if scope.lookupvar('exim::roled::enable_mail_relay') == "secondary" then -%>
# Route relay domains only if the higher prio MXes are in the allowed list
secondary:
	driver = dnslookup
	domains = ! +relay_domains : +secondary_domains
	transport = remote_smtp
	ignore_target_hosts = ! +primary_mx
	cannot_route_message = Primary MX(s) for $domain not in the allowed list
	no_more

<% end %>
<% if scope.lookupvar('exim::roled::enable_mediawiki_relay') == "true" then -%>
# Route mail generated by MediaWiki differently
wiki_mail:
domains = ! +local_domains
	driver = dnslookup
	condition = ${if and{{match_ip{$interface_address}{WIKI_INTERFACE}}{eqi{$header_X-Mailer:}{MediaWiki mailer}}}}
	errors_to = wiki@wikimedia.org
	transport = bulk_smtp
	ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; 10/8 ; 172.16/12 ; 192.168/16
	no_verify
<% end %>
<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
# Route non-local domains (including +relay_domains) via DNS MX and A records
dnslookup:
	driver = dnslookup
	domains = ! +local_domains
	transport = remote_smtp
	ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; 10/8 ; 172.16/12 ; 192.168/16
	cannot_route_message = Cannot route to remote domain $domain
	no_more
<% end -%>

# Use the system aliasfile /etc/aliases for system domains

system_aliases:
	driver = redirect
	domains = +system_domains
	data = ${lookup{$local_part}lsearch{/etc/aliases}}
	pipe_transport = address_pipe
	allow_fail
	allow_defer
	forbid_file

<% if scope.lookupvar('exim::roled::enable_mailman') == "true" then -%>
# Mailman list handling.

list_aliases:
	driver = redirect
	domains = +local_domains
	require_files = CONFDIR/aliases/$domain
	data = ${lookup{$local_part}lsearch*{CONFDIR/aliases/$domain}}
	qualify_preserve_domain
	allow_fail
	allow_defer
	forbid_file
	forbid_pipe
	include_directory = CONFDIR
<% end -%>

<% if ( scope.lookupvar('exim::roled::enable_mail_relay') == "primary" ) -%>
aliases:
	driver = redirect
	domains = +local_domains
	require_files = CONFDIR/aliases/$domain
	data = ${lookup{$local_part}lsearch*{CONFDIR/aliases/$domain}}
	qualify_preserve_domain
	allow_fail
	allow_defer
	forbid_file
	include_directory = CONFDIR
	pipe_transport = address_pipe
<% end -%>

<% if scope.lookupvar('exim::roled::enable_mailman') == "true" then -%>
# Test the mailing list address without suffix
# first, as a mailing list like wikifi-admin is a valid list name.

list:
	driver = accept
	domains = +mailman_domains
	require_files = MAILMAN_LISTS_HOME/lists/$local_part/config.pck
	transport = list

list_suffix:
	driver = accept
	domains = +mailman_domains
	require_files = MAILMAN_LISTS_HOME/lists/$local_part/config.pck
	local_part_suffix = -bounces : -bounces+* : \
				-confirm+* : -join : -leave : \
				-owner : -request : -admin : \
				-subscribe : -unsubscribe
	transport = list
<% end -%>
<% if scope.lookupvar('exim::roled::enable_mail_relay') == "primary" then -%>
# Use alias files /etc/exim4/aliases/$domain for domains like
# wikimedia.org, wikipedia.org, wiktionary.org etc.

aliases:
	driver = redirect
	domains = +local_domains
	require_files = CONFDIR/aliases/$domain
	data = ${lookup{$local_part}lsearch*{CONFDIR/aliases/$domain}}
	qualify_preserve_domain
	allow_fail
	allow_defer
	forbid_file
	include_directory = CONFDIR
	pipe_transport = address_pipe

# Alias old mailing list addresses to @lists.wikimedia.org on lily

legacy_mailing_lists:
	driver = redirect
	domains = +legacy_mailman_domains
	data = $local_part$local_part_suffix@lists.wikimedia.org
	local_parts = lsearch;CONFDIR/legacy_mailing_lists
	local_part_suffix = -bounces : -bounces+* : \
				-confirm+* : -join : -leave : \
				-owner : -request : -admin : \
				-subscribe : -unsubscribe
	local_part_suffix_optional

# LDAP accounts
ldap_account:
	driver = manualroute
	domains = wikimedia.org
	condition = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=people,dc=corp,dc=wikimedia,dc=org?mail?sub?(&(objectClass=inetOrgPerson)(mail=${quote_ldap:$local_part}@$domain)(x121Address=1))} \
			{true}fail}
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
route_list = *  aspmx.l.google.com

ldap_group:
	driver = manualroute
	domains = wikimedia.org
	condition = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=groups,dc=corp,dc=wikimedia,dc=org?businessCategory?sub?(businessCategory=${quote_ldap:$local_part}@$domain)} \
			{true}fail}
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
	route_list = *  aspmx.l.google.com

ldap_alias:
	driver = redirect
	domains = wikimedia.org
	data = ${lookup ldap \
			{user="cn=eximagent,ou=other,dc=corp,dc=wikimedia,dc=org" pass=LDAPPASSWORD \
			ldap:///ou=people,dc=corp,dc=wikimedia,dc=org?mail?sub?(&(objectClass=inetOrgPerson)(initials=${quote_ldap:$local_part}@$domain)(x121Address=1))} \
			{$value}fail}

# Send mail for IMAP accounts to sanger
imap:
	driver = manualroute
	domains = +local_domains
	condition = ${lookup sqlite{USERDB \
		SELECT 'Y' \
		FROM account \
		WHERE localpart='${quote_sqlite:$local_part}' \
			AND domain='${quote_sqlite:$domain}'}}
	local_part_suffix = +*
	local_part_suffix_optional
	transport = remote_smtp
	route_list = *  sanger.wikimedia.org

# Send RT mails to the RT server
rt:
	driver = manualroute
	domains = +rt_domains
	route_list = * streber.wikimedia.org byname
	transport = remote_smtp

# Query the OTRS MySQL server(s) for the existence of the queue address
# $local_part@$domain, and manually route to the OTRS server if
# successful.

# OTRS down, defer mail without checking the db and slowing things down -- mark 20080622
#otrs_down:
#	driver = redirect
#	allow_defer
#	data = :defer: Cannot check existence of this address right now

otrs:
	driver = manualroute
	domains = +local_domains
	condition = ${lookup mysql{SELECT value0 FROM system_address WHERE value0='${quote_mysql:$local_part@$domain}'}{true}fail}
	route_list = *  williams.wikimedia.org  byname
	transport = remote_smtp
<% end %>
<% if scope.lookupvar('exim::roled::enable_imap_delivery') == "true" then -%>
# Run a custom user filter, e.g. to sort mail into subfolders
# By default Exim filter CONFDIR/default_user_filter is run,
# which sorts mail classified spam into the Junk folder

user_filter:
	driver = redirect
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	router_home_directory = VMAIL/$domain/$local_part
	address_data = ${lookup sqlite{USERDB \
		SELECT id, filter NOTNULL AS hasfilter \
		FROM account \
		WHERE localpart='${quote_sqlite:$local_part}' \
			AND domain='${quote_sqlite:$domain}' \
	 		AND active='1'}{$value}fail}
	data = ${if eq{${extract{hasfilter}{$address_data}}}{1}{ \
		${lookup sqlite{USERDB \
		SELECT filter \
		FROM account \
		WHERE id='${quote_sqlite:${extract{id}{$address_data}}}'}}} \
		{${readfile{CONFDIR/default_user_filter}}}}
	allow_filter
	forbid_filter_dlfunc
	forbid_filter_existstest
	forbid_filter_logwrite
	forbid_filter_lookup
	forbid_filter_perl
	forbid_filter_readfile
	forbid_filter_readsocket
	forbid_filter_run
	forbid_include
	forbid_pipe
	user = vmail
	group = vmail
	directory_transport = maildir_delivery
	reply_transport = reply_transport
	no_verify

# Delivery to a Maildir mail box.
local_user:
	driver = accept
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	local_part_suffix = +*
	local_part_suffix_optional
	address_data = ${lookup sqlite{USERDB \
		SELECT id, quota \
		FROM account \
		WHERE localpart='${quote_sqlite:$local_part}' \
			AND domain='${quote_sqlite:$domain}' \
			AND active='1'}{$value}fail}
	transport = maildir_delivery
	transport_home_directory = VMAIL/$domain/$local_part
	transport_current_directory = VMAIL

# Bounce/auto-reply messages for users that have left
user_left:
	driver = accept
	domains = +local_domains
	condition = NOT_LOCALLY_SUBMITTED
	require_files = CONFDIR/userleft/$domain/$local_part
	transport = left_message

# Send all mail not destined for the local machine via a set of
# mail relays ("smart hosts")
smart_route:
	driver = manualroute
	transport = remote_smtp
	route_list = *  mchenry.wikimedia.org:lists.wikimedia.org
<% end %>
<% if scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>

# Redirect postmaster@$domain if it hasn't been accepted before
postmaster:
	driver = redirect
	domains = +local_domains
	local_parts = postmaster
	data = postmaster@$primary_hostname
<% end %>
<% if scope.lookupvar('exim::roled::enable_mailman') == "true" then -%>
	cannot_route_message = Mailing list $local_part does not exist.
<% elsif scope.lookupvar('exim::roled::enable_mail_relay') != "false" then -%>
	cannot_route_message = Address $local_part@$domain does not exist
<% end %>

##############
# Transports #
##############

begin transports

# Generic remote SMTP transport

remote_smtp:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
	interface = <; <%= scope.lookupvar('exim::roled::outbound_ips').join(" ; ") %>
<% if scope.lookupvar('exim::roled::enable_mailman' == "true" ) -%>
	helo_data = lists.wikimedia.org
<% end -%>

<% if scope.lookupvar('exim::roled::enable_mediawiki_relay') == "true" -%>
# Transport for sending out automated bulk (wiki) mail
bulk_smtp:
	driver = smtp
	hosts_avoid_tls = <; 0.0.0.0/0 ; 0::0/0
	interface = WIKI_INTERFACE
	helo_data = <; wiki-mail.wikimedia.org ; lists.wikimedia.org
<% end -%>

# Generic pipe local delivery transport (for use by alias/forward files)

address_pipe:
	driver = pipe
	return_output

<% if scope.lookupvar('exim::roled::enable_mailman') == "true" then -%>
# Mailman pipe transport
# Rewrite body headers of old mailing list addresses to new ones

list:
	driver = pipe
	command = MAILMAN_WRAP \
		'${if def:local_part_suffix \
			{${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}} \
			{post}}' \
		$local_part
	current_directory = MAILMAN_LISTS_HOME
	home_directory = MAILMAN_LISTS_HOME
	user = MAILMAN_UID
	group = MAILMAN_GID
	#headers_rewrite = \N^.*@(mail\.)?wiki[mp]edia\.org$\N "${if exists{MAILMAN_LISTS_HOME/lists/$local_part/config.pck}{$local_part@lists.wikimedia.org}fail}" ct

<% end %>
<% if scope.lookupvar('exim::roled::enable_imap_delivery') == "true" then -%>
# Delivery via Dovecot's "deliver" LDA. The advantage over using Exim's
# internal Maildir appendfile transport is that it can immediately update
# Dovecot's internal indexes for better performance.

dovecot_delivery:
	driver = pipe
	command = DELIVER -m ${extract{mailbox}{$address_data}{$value}{INBOX}}
	log_output
	return_fail_output
	message_prefix =
	message_suffix =
	delivery_date_add
	envelope_to_add
	return_path_add
	user = vmail
	group = vmail

# Exim appendfile transport for Maildir delivery

maildir_delivery:
	driver = appendfile
	maildir_format
	directory = ${if def:address_file{$address_file}{$home}}
	create_directory
	create_file = belowhome
	delivery_date_add
	envelope_to_add
	return_path_add
	user = vmail
	group = vmail

	# Quota support
	quota = ${if !eq{$received_protocol}{local}{${extract{quota}{$address_data}{${value}K}{0}}}}
	quota_is_inclusive = false
	quota_warn_threshold = 100%
	quota_warn_message = ${expand:${readfile{CONFDIR/quota_warn_message}}}
	maildir_use_size_file
	maildir_quota_directory_regex = ^(?:cur|new|\.(?!Trash).*)
	maildir_tag = ,S=$message_size

# Autoreply bounce transport for users that have left the organization

left_message:
	driver = autoreply
	file = CONFDIR/userleft/$domain/$local_part
	file_expand
	return_message
	from = Wikimedia Foundation <postmaster@wikimedia.org>
	to = $sender_address
	reply_to = office@wikimedia.org
	subject = User ${quote_local_part:$local_part}@$domain has left the organization: returning message to sender

reply_transport:
	driver = autoreply
<% end %>
<% if scope.lookupvar('exim::roled::enable_mail_submission') == "true" then -%>
##################
# Authenticators #
##################

begin authenticators

# PLAIN authenticator
# Expects the password field to contain a "LDAP format" hash. Only
# (unsalted) {md5}, {sha1}, {crypt} and {crypt16} are supported.

plain:
	driver = plaintext
	public_name = PLAIN
	server_prompts = :
	server_condition = ${lookup sqlite{USERDB \
		SELECT password \
		FROM account \
		WHERE localpart||'@'||domain='${quote_sqlite:$auth2}' \
			AND active='1'} \
		{${if crypteq{$auth3}{$value}}}{false}}
	server_set_id = $auth2
	server_advertise_condition = ${if def:tls_cipher}
<% end %>
###############
# Retry rules #
###############

begin retry

<% if scope.lookupvar('exim::roled::enable_mediawiki_relay') == "true" then -%>
*	*	senders=wiki@wikimedia.org      F,1h,15m; G,8
<% end -%>
*	*	F,2h,15m; G,16h,1h,1.5; F,4d,6h
<% if ( scope.lookupvar('exim::roled::enable_mail_relay') != "false" ) -%>

#################
# Rewrite rules #
#################

begin rewrite

<% end %>
<% if scope.lookupvar('exim::roled::enable_mailman') == "true" then -%>
\N^.*@(mail\.)?wiki[mp]edia\.org$\N "${if exists{MAILMAN_LISTS_HOME/lists/$local_part/config.pck}{$local_part@lists.wikimedia.org}fail}" ct
<% end %>
<% if ( scope.lookupvar('exim::roled::enable_mail_relay') != "false" ) -%>
# Rewrite the envelope From for mails from internal servers in *.pmtpa.wmnet,
# as they are usually rejected by sender domain address verification.
*@*.pmtpa.wmnet		root@wikimedia.org	F
*@*.eqiad.wmnet		root@wikimedia.org	F
*@*.esams.wmnet		root@wikimedia.org	F
#*@*.wikimedia.org	root@wikimedia.org	F
<% end -%>
