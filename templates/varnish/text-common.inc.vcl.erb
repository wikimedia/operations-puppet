// Common functions for the Text/Mobile Varnish clusters

sub restore_cookie {
	// Restore the original Cookie header for upstream
	// Assumes client header X-Orig-Cookie has been filtered!
	if (bereq.http.X-Orig-Cookie) {
		set bereq.http.Cookie = bereq.http.X-Orig-Cookie;
		unset bereq.http.X-Orig-Cookie;
	}
}

sub evaluate_cookie {
	// For hash->lookup purposes, if there's a valid-seeming session|token
	// cookie, replace it with the shared Cookie value "vuc=1", otherwise
	// remove the Cookie completely.  In either case, in vcl_(pass|miss)
	// on the way to any backend fetch, it will be restored to the
	// original value.
	// Later in common_fetch, we'll create hit-for-pass objects for any
	// response with Vary:Cookie and Cookie:vuc=1.  This will allow
	// logged-in users to share the anonymous users' cache for
	// non-Vary:Cookie responses, and then share a single hit-for-pass
	// object in a single Vary slot per object for those responses that
	// should Vary:Cookie.
	if (req.restarts == 0) {
		set req.http.X-Orig-Cookie = req.http.Cookie;
		if (req.http.Cookie ~ "([sS]ession|Token)=") {
			set req.http.Cookie = "vuc=1";
		} else {
			unset req.http.Cookie;
		}
	}
}

sub pass_authorization {
	// As a general rule, per the RFCs, shared caches shouldn't use cached
	// responses for requests with Authorization headers (with a few
	// notable exceptions aside).  The default vcl_recv (which text
	// doesn't use) in varnish does this alongside its pass for Cookie.
	// We deal with Cookies properly elsewhere.
	//
	// By letting Authorization reqs cache, we're breaking our own OAuth
	// in some corner cases: https://phabricator.wikimedia.org/T105387
	// Any browser/curl fetch of an OAuth URL without the header can
	// cause a redirect to be cached, which then affects real fetches that
	// have the Authorization header set, which is Bad.
	//
	// It's *probably* best to just pass all Authorization-headered
	// requests in general, but on the other hand, I see a lot of random
	// Authorization headers in our traffic that don't look like stuff
	// we're using or want to pay attention to, and we've otherwise seemed
	// ok on this stuff.  So for now, only (pass) on ones that seem to
	// have OAuth data, with the same header-matching as in:
	// https://phabricator.wikimedia.org/diffusion/EOAU/browse/master/backend/MWOAuthUtils.php;8029ef146211a1016b1f8e676944c3750f78b0eb$89
	if (req.http.Authorization ~ "^OAuth ") {
		return (pass);
	}
}

sub vcl_hash {
	// The cookies below represent mobile preferences that can be set for anonymous users.
	if (req.http.X-Subdomain) {
<% if scope.function_hiera(["cluster"]) == "cache_text" -%>
		// this splits the cache between mobile and desktop variants in general
		// the text-cluster conditional is temporary, to avoid effectively wiping the primary cache
		// on the legacy mobile cluster on deploy
		hash_data("Mobile-Subdomain");
<% end -%>

		// Split the cache for the images-disabled variant of the mobile site.
		if (req.http.X-Orig-Cookie ~ "(^|;\s*)disableImages=1" || req.http.Cookie ~ "(^|;\s*)disableImages=1") {
			hash_data("disableImages=1");
		}

		// Split the cache if the NetSpeed cookie is set and if its value is 'B'. The only other
		// permissable value is 'A', which is equivalent to not having the cookie at all, so we
		// don't need to update the hash in that case.
		if (req.http.X-Orig-Cookie ~ "(^|;\s*)NetSpeed=B" || req.http.Cookie ~ "(^|;\s*)NetSpeed=B") {
			hash_data("NetSpeed=B");
		}

		// Split the cache for the beta variant of the mobile site.
		if (req.http.X-Orig-Cookie ~ "(^|;\s*)optin=beta" || req.http.Cookie ~ "(^|;\s*)optin=beta") {
			hash_data("optin=beta");
		}
	}
<% if scope.function_hiera(["cluster"]) == "cache_mobile" -%>
	else {
		// this temporarily protects the mobile cluster (which is
		// going away at the end of their functional merger) from
		// having its cache polluted by someone sending text-domain
		// requests to the mobile IP address via local DNS hacks
		hash_data("Desktop");
	}
<% end -%>
}

// fe+be common recv code
sub common_recv {
	if (req.request != "GET" && req.request != "HEAD") {
		return (pass);
	}

	if (req.http.X-Wikimedia-Debug == "1" || req.http.X-Wikimedia-Security-Audit == "1") {
		return (pass);
	}

	call evaluate_cookie;
	call pass_authorization;
}

// fe+be common fetch code
sub common_fetch {
	if (req.http.X-Subdomain && (req.url ~ "mobileaction=" || req.url ~ "useformat=")) {
		set beresp.ttl = 60 s;
	}

	// There are a couple different conditions here under which we set a
	// 601s hit-for-pass object based on response conditions in vcl_fetch:
	// 1) Calculated TTL <= 0 + Status < 500 + No underlying cache hit:
	//    These are generally uncacheable responses.  The 5xx exception
	//    avoids us accidentally replacing a good stale/grace object with
	//    an hfp (and then repeatedly passing on potentially-cacheable
	//    content) due to an isolated 5xx response, and the exception for
	//    underlying cache hits (detected from X-Cache) is to avoid
	//    creating a persist HFP object when a lower-level varnish
	//    returned an expired object under grace-mode rules.
	// 2) vuc=1 + Vary:Cookie
	//    All requests with real login session|token cookies share the
	//    Cookie:vuc=1 value for Vary purposes.  This allows them to share
	//    a single hit-for-pass object here if the response shouldn't be
	//    shared between users (Vary:Cookie).
	if (
	    (
		beresp.ttl <= 0s
		&& beresp.status < 500
		&& (!beresp.http.X-Cache || beresp.http.X-Cache !~ " hit\(")
	    ) || (
		req.http.Cookie == "vuc=1"
		&& beresp.Vary ~ "(^|,)\s*Cookie\s*(,|$)"
	    )
	) {
		set req.http.X-CDIS = req.http.X-CDIS + "+chfp"; // +created-hit-for-pass
		set beresp.ttl = 601s;
		return (hit_for_pass);
	}
}
