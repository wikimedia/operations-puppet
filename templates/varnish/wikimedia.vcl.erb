# Wikimedia VCL file for <%= scope.lookupvar("::fqdn") %>, site <%= scope.lookupvar("::site") %>
# This file is managed by Puppet!

<% if has_variable?("enable_geoiplookup") and enable_geoiplookup == "true" -%>
include "geoip.inc.vcl";
<% end -%>

# ACLs

acl purge { 
	"127.0.0.1";
}

<% if ! wikimedia_networks.empty? -%>
acl wikimedia_nets {
<% wikimedia_networks.each do |entry|
	subnet, mask = entry.split("/", 2)
-%>
	"<%= subnet %>"/<%= mask %>;
<% end -%>
}
<% end -%>

# Hosts we trust for XFF
<% if ! xff_sources.empty? -%>
acl allow_xff {
<% xff_sources.each do |entry|
	subnet, mask = entry.split("/", 2)
-%>
	"<%= subnet %>"/<%= mask %>;
<% end -%>
}
<% end -%>

# Backend probes

/*
probe text {
	.request =
		"GET /wiki/Main_Page HTTP/1.1"
		"Host: en.wikipedia.org"
		"User-agent: Varnish backend check"
		"Connection: close";	
}
*/

# FIXME: need to support checks from pmtpa to backend bits app servers
<% if vcl == "bits" and scope.lookupvar("::site") == "esams" -%>
probe bits {
	.request =
		"GET /images/wikimedia-button.png HTTP/1.1"
		"Host: bits.wikimedia.org"
		"User-agent: Varnish backend check"
		"Connection: close";
	.timeout = 5s;	
}
<% elsif /frontend/.match(vcl) -%>
# frontends in front of other varnish instances should send
# probes that don't depend on the app backend
probe varnish {
	.request =
		"GET /check HTTP/1.1"
		"Host: varnishcheck"
		"User-agent: Varnish backend check"
		"Connection: close";
	.timeout = 500ms;
	.interval = 1s;
	.window = 3;
	.threshold = 2;
}
<% elsif vcl == "blog" -%>
probe blog {
	.request =
		"HEAD /wp-content/themes/WP-Victor.git/favicon.ico HTTP/1.1"
		"Host: blog.wikimedia.org"
		"User-agent: Varnish backend check"
		"Connection: close";
	.timeout = 5s;	
}
<% elsif varnish_backend_options.fetch("probe") == "options" -%>
probe options {
	.request =
		"OPTIONS * HTTP/1.0"
		"Connection: close";
	.timeout = 5s;	
}
<% else -%>
probe bits {
	.request =
		"GET /w/load.php HTTP/1.1"
		"Host: en.wikipedia.org"
		"User-agent: Varnish backend check"
		"Connection: close";
	.timeout = 1s;
	.interval = 1s;
	.window = 3;
	.threshold = 2;
}
<% end -%>

probe upload {
	.url = "/pybaltestfile.txt";
	.timeout = 2s;
}

# Backends

# List of Puppet generated backends
<% varnish_backends.each do |backend| -%>
<% if backend =~ /^[0-9\.]+$/ -%>
backend ipv4_<%= backend.gsub(".", "_") %> {
<% else -%>
backend <%= backend.split(".")[0].gsub("-", "_") %> {
<% end -%>
	.host = "<%= backend %>";
	.port = "<%= varnish_backend_options.fetch("port", "80") %>";
	.connect_timeout = <%= varnish_backend_options.fetch("connect_timeout", "2s") %>;
	.first_byte_timeout = <%= varnish_backend_options.fetch("first_byte_timeout", "35s") %>;
	.between_bytes_timeout = <%= varnish_backend_options.fetch("between_bytes_timeout", "2s") %>;
	.max_connections = <%= varnish_backend_options.fetch("max_connections", "100") %>;
	.probe = <%= varnish_backend_options.fetch("probe", "bits") %>;
}

<% end -%>

# Directors
# Expected format: { "director name" => [ "backend1", "backend2" ] }
<% varnish_directors.keys.each do |director| -%>
director <%= director %> hash {
	.retries = 2;
<% varnish_directors[director].each do |backend| -%>
	{
<% if backend =~ /^[0-9\.]+$/ -%>
		.backend = ipv4_<%= backend.gsub(".", "_") %>;
<% else -%>
		.backend = <%= backend.split(".")[0].gsub("-", "_") %>;
<% end -%>
		.weight = 10;
	}
<% end -%>
}
<% end -%>

# Functions

sub vcl_recv {
	if (req.backend.healthy) {
		set req.grace = 5m;
	} else {
		set req.grace = 60m;
	}

	if (req.request != "GET" && req.request != "HEAD" && req.request != "PURGE" && req.request != "POST") {
		/* We only deal with GET and HEAD by default */
		error 403 "HTTP method not allowed.";
	}

	/* Support HTTP PURGE from localhost */
	if (req.request == "PURGE") { 
		if (!client.ip ~ purge) {
			error 405 "Denied.";
		# This is a stupid hack to make varnishhtcpd work - it's using a perl mod that sends purge reqs like
		# PURGE http://de.wikipedia.orghttp://de.wikipedia.org/w/index.php
		} else if (req.url ~ "^http:") {
			set req.url = regsub ( req.url, "^http://[\w.]+(/.*)", "\1");	
		}
		return (lookup);
	}
	
<% if has_variable?("xff_sources") and xff_sources.length > 0 -%>
	/* Ensure we only accept Forwarded headers from the SSL proxies */
	if (client.ip ~ allow_xff) {
		// Do nothing. It seems you can't do !~ with IP matches
	} else {
		// Strip the headers, we shouldn't trust these from anything other
		// than hosts we specify. Needed for the geoiplookup code later on
		// as it will use xff. MediaWiki uses xfp.
		set req.http.X-Forwarded-For = client.ip;
		unset req.http.X-Forwarded-Proto;
	}
<% end -%>

	/* Select the default backend(s) */
	set req.backend = backend;

	if ( req.http.host ~ "^varnishcheck" ) {
		error 200 "OK"; 
	}

	/* Function vcl_recv in <%= vcl %>.inc.vcl will be appended here */
}

sub vcl_fetch {
	set beresp.grace = 60m;

<% if varnish_backend_options.fetch("retry5x", "0") == "1" -%>
	if (beresp.status > 499 && beresp.status < 505) {
		return(restart);
	}
<% end -%>
	if (beresp.status > 400) {
		set beresp.ttl = 0s;
		return(hit_for_pass);
	}

	/* Function vcl_fetch in <%= vcl %>.inc.vcl will be appended here */
}

sub vcl_hit {
	if (req.request == "PURGE") {
		purge;
		error 200 "Purged.";
	}
	
	/* Function vcl_hit in <%= vcl %>.inc.vcl will be appended here */
}

sub vcl_miss {
	if (req.request == "PURGE") {
		purge;
		error 200 "Cache miss";
	}

	/* Function vcl_miss in <%= vcl %>.inc.vcl will be appended here */
}

sub vcl_deliver {
	if (obj.hits > 0) {
		set resp.http.X-Cache<%= instancesuffix %> = "hit (" + obj.hits + ")";
	} else {
		set resp.http.X-Cache<%= instancesuffix %> = "miss (0)";
	}

	/* Function vcl_deliver in <%= vcl %>.inc.vcl will be appended here */
}

sub vcl_error {
<% if varnish_backend_options.fetch("retry5x", "0") == "1" -%>
	if (obj.status == 503 && req.restarts < 4) {
		return(restart);
	}
<% end -%>
	/* Function vcl_error in <%= vcl %>.inc.vcl will be appended here */
}


/* Include the VCL file for this role */
include "<%= vcl %>.inc.vcl";
