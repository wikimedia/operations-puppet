// Varnish VCL include file

// Note: This requires "import header" in the including VCL

C{
    #include <dlfcn.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <maxminddb.h>
    #include <pthread.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
    #include <arpa/inet.h>
    #include <alloca.h>

    MMDB_s* mmdb = NULL;
}C

// XXX this is no worse than the previous PS's model and a little more
// efficient, but needs more investigation on globals vs VCL-reload cycle...
sub vcl_init { C{
    if (!mmdb) {
        mmdb = malloc(sizeof(*mmdb));
        int st = MMDB_open("/usr/share/GeoIP/GeoIP2-City.mmdb", MMDB_MODE_MMAP, mmdb);
        if (st != MMDB_SUCCESS) {
            free(mmdb);
            mmdb = NULL;
            // XXX log/complain loudly?
        }
    }
}C }

/* XXX if globals are VCL-scoped ...
sub vcl_fini { C{
    if (mmdb) {
        MMDB_close(mmdb);
        free(mmdb);
        mmdb = NULL;
    }
}C }
*/

// runtime stuff
C{
    /*
     * Write the relevant client IP address to a character string,
     * protecting against possible invalid data in the source
     * "X-Client-IP" header set by common VCL.
     *
     * This function will write at most INET6_ADDRSTRLEN characters to "ip"
     * including the (always present) terminal NUL.  The return value is the
     * zero for success, non-zero for failure (input IP is invalid or the
     * encoding of it is too long).
     */
    static int geo_get_xcip(const struct sess *sp, char *ip) {
        const char *client_ip = VRT_GetHdr(sp, HDR_REQ, "\014X-Client-IP:");
        size_t len = 0;
        int rv = -1;

        if (client_ip != NULL) {
            len = strspn(client_ip, "1234567890abcdefABCDEF.:");
            if (len > 0 && len < INET6_ADDRSTRLEN) {
                memcpy(ip, client_ip, len);
                ip[len] = '\0';
                rv = 0;
            }
        }

        return rv;
    }

    /*
     * Make a string safe to use as a cookie value in a Set-Cookie header
     * by replacing CTLs, DEL, 8-bit characters, space, double-quote,
     * comma, semicolon, and backslash with an underscore.
     */
    static void geo_sanitize_for_cookie(char *p) {
        while(*p) {
            if (*p < 0x21 || *p > 0x7E || strchr("\",;\\", *p))
                *p = '_';
            *p++;
        }
    }

    /*
     * Extract the topmost part of the domain name for which a cookie may be set.
     * This consists of the public suffix (e.g., 'org') plus one more level.
     *
     * In Wikimedia's case, this is always the top two parts of the name (for example,
     * 'wikipedia.org' for 'en.m.wikipedia.org'. But we handle other common cases correctly too,
     * like 'news.bbc.co.uk' (which may set cookies for bbc.co.uk, but not the entire co.uk public
     * suffix), by assuming that if either of the top two levels is less than three characters
     * long, then the public suffix contains two parts. A fully comprehensive and correct solution
     * would require checking against a public suffix database like <https://publicsuffix.org/>.
     */
    static const char* geo_get_top_cookie_domain(const char *host) {
        const char *last, *second_last, *third_last, *pos, *top_cookie_domain;

        if (host == NULL) {
            return NULL;
        }

        last = second_last = third_last = host;
        for (pos = host; *pos != '\0'; pos++) {
            if (*pos == '.') {
                third_last = second_last;
                second_last = last;
                last = pos;
            }
        }

        // If either the second- or top-level domain is less than three characters long,
        // assume that the domain uses a two-part public suffix (like '.co.uk') and include
        // one additional level in the result.  Also, if the name ends in
        // '.beta.wmflabs.org', make a special case for that.
        if (!strcmp(third_last, ".beta.wmflabs.org") || (pos - last) <= 3 || (last - second_last) <= 3) {
            top_cookie_domain = third_last;
        } else {
            top_cookie_domain = second_last;
        }

        if (*top_cookie_domain == '.') {
            top_cookie_domain++;
        }

        return top_cookie_domain;
    }

    typedef enum _geo_idx_t {
        GEO_IDX_CITY    = 0,
        GEO_IDX_COUNTRY = 1,
        GEO_IDX_REGION  = 2,
        GEO_IDX_LAT     = 3,
        GEO_IDX_LON     = 4,
        _GEO_IDX_SIZE   = 5,
    } geo_idx_t;

    static void geo_xcip_output_json(struct sess* sp, const char* ip, char** geo) {
        char out[255];
        int out_size = snprintf(out, 255, "Geo = {\"city\":\"%s\",\"country\":\"%s\",\"region\":\"%s\",\"lat\":\"%s\",\"lon\":\"%s\",\"IP\":\"%s\"}",
            geo[GEO_IDX_CITY],
            geo[GEO_IDX_COUNTRY],
            geo[GEO_IDX_REGION],
            geo[GEO_IDX_LAT],
            geo[GEO_IDX_LON],
            ip
        );
        if (out_size >= 254) // Don't use truncated output
            return;

        VRT_synth_page(sp, 0, out, vrt_magic_string_end);
        char *now = VRT_time_string(sp, VRT_r_now(sp));
        VRT_SetHdr(sp, HDR_OBJ, "\016Last-Modified:", now, vrt_magic_string_end);
        VRT_SetHdr(sp, HDR_OBJ, "\016Cache-Control:", "private, max-age=86400, s-maxage=0", vrt_magic_string_end);
        VRT_SetHdr(sp, HDR_OBJ, "\015Content-Type:", "text/javascript", vrt_magic_string_end);
    }

    static void geo_xcip_output_cookie(struct sess* sp, const char* ip, char** geo) {
        char host_safe[50];
        char out[255];
        int out_size = snprintf(out, 255, "GeoIP=%s:%s:%s:%s:%s:%s",
            geo[GEO_IDX_COUNTRY],
            geo[GEO_IDX_REGION],
            geo[GEO_IDX_CITY],
            geo[GEO_IDX_LAT],
            geo[GEO_IDX_LON],
            (strchr(ip, ':') != NULL) ? "v6" : "v4"
        );
        if (out_size >= 254) // Don't use truncated output
            return;

        geo_sanitize_for_cookie(out);
        const char *host = VRT_GetHdr(sp, HDR_REQ, "\005host:");
        if (!host)
            return;
        if (snprintf(host_safe, sizeof(host_safe), "%s", geo_get_top_cookie_domain(host)) >= sizeof(host_safe))
            return;
        geo_sanitize_for_cookie(host_safe);
        // Use libvmod-header to ensure the Set-Cookie header we are adding does not
        // clobber or manipulate existing cookie headers (if any).
        Vmod_Func_header.append(sp, HDR_RESP, "\013Set-Cookie:", out, "; Path=/; secure; Domain=.",
            host_safe, vrt_magic_string_end);
    }

    static const char* lookup_path[_GEO_IDX_SIZE][4] = {
        {"city", "names", "en", NULL},
        {"country", "iso_code", NULL, NULL},
        {"subdivisions", "0", "iso_code", NULL},
        {"location", "latitude", NULL, NULL},
        {"location", "longitude", NULL, NULL},
    };

    static void geo_xcip_output(struct sess *sp, const bool json) {
        char ip[INET6_ADDRSTRLEN];
        int gai_error, mmdb_error;

        if (!mmdb)
            return;
        if (geo_get_xcip(sp, ip))
            return;
        MMDB_lookup_result_s result = MMDB_lookup_string(mmdb, ip, &gai_error, &mmdb_error);
        if (gai_error || mmdb_error != MMDB_SUCCESS || !result.found_entry)
            return;

	// Parse results into "geo" on the stack, which is always full of
	// pointers.  The pointers are to empty strings if results are lacking.
	char* geo[_GEO_IDX_SIZE];
        char empty[1];
        empty[0] = '\0';
        geo_idx_t g;
        for (g = 0; g < _GEO_IDX_SIZE; g++) {
            char *data = empty;
            MMDB_entry_data_s entry_data;
            int status = MMDB_aget_value(&result.entry, &entry_data, lookup_path[g]);
            if (status == MMDB_SUCCESS && entry_data.has_data) {
                switch(entry_data.type){
                    case MMDB_DATA_TYPE_UTF8_STRING:
                        data = alloca(entry_data.data_size + 1);
                        memcpy(data, entry_data.utf8_string, entry_data.data_size);
                        data[entry_data.data_size] = '\0';
                        break;
                    case MMDB_DATA_TYPE_DOUBLE:
                        data = alloca(16);
                        snprintf(data, 16, "%3.2f", entry_data.double_value);
                        break;
                    default:
                        break;
                }
            }
            geo[g] = data;
        }

        if (json)
            geo_xcip_output_json(sp, ip, geo);
        else
            geo_xcip_output_cookie(sp, ip, geo);
    }
}C

// Emits JSON
sub geoip_lookup { C{geo_xcip_output(sp, true);}C }

// Emits a Set-Cookie
sub geoip_cookie { C{geo_xcip_output(sp, false);}C }
