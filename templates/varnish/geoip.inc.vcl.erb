// Varnish VCL include file

// Note: This requires "import header" in the including VCL

// Init GeoIP code
C{
	#include <dlfcn.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>
	#include <maxminddb.h>
	#include <pthread.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <netdb.h>
	#include <arpa/inet.h>

	MMDB_s *mmdb = NULL;

	int geo_get_relevant_ip (const struct sess *sp, char *ip, size_t maxlen);
	void geo_sanitize_for_cookie (char *string);
	void geo_set_cache_control (const struct sess *sp);
	const char * geo_get_top_cookie_domain (const char *host);

	const char *
	mmdb_lookup(struct sess *sp, const char *ipstr, const char **lookup_path)
	{
		char *data = NULL;

		if (mmdb == NULL) {
			mmdb = malloc(sizeof(MMDB_s));
			if (mmdb == NULL) {
				return NULL;
			}

			int status = MMDB_open("/usr/share/GeoIP/GeoIP2-City.mmdb", MMDB_MODE_MMAP, mmdb);
			if (MMDB_SUCCESS != status) {
				return NULL;
			}
		}

		int gai_error, mmdb_error;
		MMDB_lookup_result_s result = MMDB_lookup_string(mmdb, ipstr, &gai_error, &mmdb_error);

		if (0 != gai_error) {
			return NULL;
		}

		if (MMDB_SUCCESS != mmdb_error) {
			return NULL;
		}

		// Parse results
		MMDB_entry_data_s entry_data;
		int exit_code = 0;
		size_t strsize = 0;

		if (result.found_entry) {
			int status = MMDB_aget_value(&result.entry, &entry_data, lookup_path);

			if (MMDB_SUCCESS != status) {
				exit_code = 4;
			}

			if (entry_data.has_data) {
				switch(entry_data.type){
					case MMDB_DATA_TYPE_UTF8_STRING:
						data = strndup(entry_data.utf8_string, entry_data.data_size);
						break;
					case MMDB_DATA_TYPE_DOUBLE:
						strsize = 1 + 2 + 1 + 2 + 1; // -NN.MM\0
						data = malloc(strsize);
						snprintf(data, strsize, "%2.2f", entry_data.double_value);
						break;
					default:
						exit_code = 6;
						break;
				}
		}
		} else {
			exit_code = 5;
		}
		if (exit_code != 0) {
			data = malloc(sizeof(char)*2);
			sprintf(data, "%s", "");
		}

		/*
		char *cp;
		cp = WS_Dup(sp->wrk->ws, data);
		free(data);
		return cp;
		*/

		return data;

	}

	const char*
	mmdb_city(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"city", "names", "en", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	const char*
	mmdb_country(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"country", "names", "en", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	const char*
	mmdb_region(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"subdivisions", "0", "iso_code", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	const char*
	mmdb_country_code(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"country", "iso_code", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	const char*
	mmdb_latitude(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"location", "latitude", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	const char*
	mmdb_longitude(struct sess *sp, const char *ipstr)
	{
		const char *lookup_path[] = {"location", "longitude", NULL};
		return mmdb_lookup(sp, ipstr, lookup_path);
	}

	/*
	 * Write the relevant client IP address to a character string,
	 * protecting against possible invalid data in the source
	 * "X-Client-IP" header set by common VCL.
	 *
	 * This function will write at most maxlen-1 characters into the output string (the maxlen'th
	 * character then gets the terminating '\0'). The output is always null-terminated. The return
	 * value is the number of characters printed (not including the final '\0'), or -1 if no
	 * relevant client IP is available or if its length exceeds the maximum.
	 */
	int
	geo_get_relevant_ip(const struct sess *sp, char *ip, size_t maxlen) {
		const char *client_ip = VRT_GetHdr(sp, HDR_REQ, "\014X-Client-IP:");
		size_t len = 0;

		if (client_ip != NULL) {
			len = strspn(client_ip, "1234567890abcdefABCDEF.:");
		}

		if (len == 0 || len >= maxlen) {
			return -1;
		}

		memcpy(ip, client_ip, len);
		ip[len] = '\0';
		return len;
	}

	/*
	 * Make a string safe to use as a cookie value in a Set-Cookie header
	 * by replacing CTLs, DEL, 8-bit characters, space, double-quote,
	 * comma, semicolon, and backslash with an underscore.
	 */
	void
	geo_sanitize_for_cookie(char *string) {
		char *ptr;
		for (ptr = string; ptr && *ptr; ptr++) {
			if (*ptr < 0x21 || *ptr > 0x7E || strchr("\",;\\", *ptr)) {
				*ptr = '_';
			}
		}
	}

	/*
	 * Set Last-Modified and Cache-Control headers for GeoIP requests.
	 */
	void
	geo_set_cache_control(const struct sess *sp) {
		char *now = VRT_time_string(sp, VRT_r_now(sp));
		VRT_SetHdr(sp, HDR_OBJ, "\016Last-Modified:", now, vrt_magic_string_end);
		VRT_SetHdr(sp, HDR_OBJ, "\016Cache-Control:", "private, max-age=86400, s-maxage=0", vrt_magic_string_end);
	}


	/*
	 * Extract the topmost part of the domain name for which a cookie may be set.
	 * This consists of the public suffix (e.g., 'org') plus one more level.
	 *
	 * In Wikimedia's case, this is always the top two parts of the name (for example,
	 * 'wikipedia.org' for 'en.m.wikipedia.org'. But we handle other common cases correctly too,
	 * like 'news.bbc.co.uk' (which may set cookies for bbc.co.uk, but not the entire co.uk public
	 * suffix), by assuming that if either of the top two levels is less than three characters
	 * long, then the public suffix contains two parts. A fully comprehensive and correct solution
	 * would require checking against a public suffix database like <https://publicsuffix.org/>.
	 */
	const char *
	geo_get_top_cookie_domain(const char *host) {
		const char *last, *second_last, *third_last, *pos, *top_cookie_domain;

		if (host == NULL) {
			return NULL;
		}

		last = second_last = third_last = host;
		for (pos = host; *pos != '\0'; pos++) {
			if (*pos == '.') {
				third_last = second_last;
				second_last = last;
				last = pos;
			}
		}

		// If either the second- or top-level domain is less than three characters long,
		// assume that the domain uses a two-part public suffix (like '.co.uk') and include
		// one additional level in the result.
		if ((pos - last) <= 3 || (last - second_last) <= 3) {
			top_cookie_domain = third_last;
		} else {
			top_cookie_domain = second_last;
		}

		if (*top_cookie_domain == '.') {
			top_cookie_domain++;
		}

		return top_cookie_domain;
	}
}C

sub geoip_lookup {
	set obj.http.Content-Type = "text/javascript";

	C{
		char ip[50];
		char json[255];

		if (geo_get_relevant_ip(sp, ip, sizeof(ip)) == -1) {
			return;
		}

		snprintf(json, 255, "Geo = {\"city\":\"%s\",\"country\":\"%s\",\"region\":\"%s\",\"lat\":\"%s\",\"lon\":\"%s\",\"IP\":\"%s\"}",
			mmdb_city(sp, ip),
			mmdb_country_code(sp, ip),
			mmdb_region(sp, ip),
			mmdb_latitude(sp, ip),
			mmdb_longitude(sp, ip),
			ip
		);
		VRT_synth_page(sp, 0, json, vrt_magic_string_end);

		geo_set_cache_control(sp);
	}C
}


sub geoip_cookie {
	C{
		char *geo_header;
		char cookie_buf[255];
		char ip[50];
		char host_safe[50];

		const char *host = VRT_GetHdr(sp, HDR_REQ, "\005host:");
		if (host == NULL) {
			return;
		}
		if (snprintf(host_safe, sizeof(host_safe), "%s", geo_get_top_cookie_domain(host)) >= sizeof(host_safe)) {
			return;
		}
		geo_sanitize_for_cookie(host_safe);

		if (geo_get_relevant_ip(sp, ip, sizeof(ip)) == -1) {
			return;
		}

		int snp_len;
		// Set-Cookie: GeoIP=US:CA:San_Francisco:37.77:-122.41:v4; path=/
		snp_len = snprintf(cookie_buf, sizeof(cookie_buf), "GeoIP=%s:%s:%s:%s:%s:%s",
			mmdb_country_code(sp, ip),
			mmdb_region(sp, ip),
			mmdb_city(sp, ip),
			mmdb_latitude(sp, ip),
			mmdb_longitude(sp, ip),
			(strchr(ip, ':') != NULL) ? "v6" : "v4"
		);

		// don't use snprintf()-truncated output
		if (snp_len < sizeof(cookie_buf)) {
			geo_sanitize_for_cookie(cookie_buf);

			// Use libvmod-header to ensure the Set-Cookie header we are adding does not
			// clobber or manipulate existing cookie headers (if any).
			Vmod_Func_header.append(sp, HDR_RESP, "\013Set-Cookie:", cookie_buf, "; Path=/; Domain=.",
				host_safe, vrt_magic_string_end);
		}
	}C
}
