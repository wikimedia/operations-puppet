include "misc-common.inc.vcl";

sub cluster_be_recv_pre_purge { }

sub cluster_be_recv_applayer_backend {
<%
    def set_director(dirname)
        if @varnish_version4
            dir = @app_directors[dirname]
            if dir['type'] == 'hash'
                action = "set req.backend_hint = #{dirname}.backend(req.http.X-Client-IP);"
            else
                action = "set req.backend_hint = #{dirname}.backend();"
            end
        else
            action = "set req.backend = #{dirname};"
        end
        return action
    end

    def_action = error_synth(404, 'Domain not served here')
    if_stmts = []
    @vcl_config['req_handling'].keys.sort.each do |reqhost|
        options = @vcl_config['req_handling'][reqhost]
        if options.has_key?('subpaths')
            path_def_action = error_synth(404, 'Not Found')
            path_ifs = []
            options['subpaths'].keys.sort.each do |subpath|
                path_action = set_director(options['subpaths'][subpath]['director'])
                if subpath == 'default'
                    path_def_action = path_action
                else
                    path_ifs.push(%Q[if (req.url ~ "#{subpath}") {\n            #{path_action}\n        }])
                end
            end
            if path_ifs.empty?
                host_action = path_def_action
            else
                path_ifs.push("e {\n            #{path_def_action}\n        }")
                host_action = path_ifs.join(' els')
            end
        else
            host_action = set_director(options['director'])
        end

        if reqhost == 'default'
            def_action = host_action
        else
            if reqhost =~ /^[-.A-Za-z0-9]+$/
                hostop = '=='
            else
                hostop = '~'
            end
            hostcmp = %Q[req.http.Host #{hostop} "#{reqhost}"]
            if_stmts.push("if (#{hostcmp}) {\n        #{host_action}\n    }")
        end
    end
    if if_stmts.empty?
        set_backend = def_action
    else
        if_stmts.push("e {\n        #{def_action}\n    }")
        set_backend = if_stmts.join(' els')
    end
%>
    <%= set_backend -%>

<%
    maint_stmts = []
    @app_directors.keys.sort.each do |dirname|
        dir = @app_directors[dirname]
        if dir.key?('maintenance')
            action = error_synth(503, dir['maintenance'])
            if @varnish_version4
                # is this really correct in V4?
                maint_stmts.push(%Q[if (req.backend_hint == "#{dirname}") {\n        #{action}    }])
            else
                maint_stmts.push(%Q[if (req.backend == "#{dirname}") {\n        #{action}    }])
            end
        end
    end
    all_maint = maint_stmts.join(' els')
%>
    <%= all_maint -%>
}

sub cluster_be_recv {
    call misc_recv_pass;
}

sub cluster_be_hash { }
sub cluster_be_hit { }
sub cluster_be_miss { }
sub cluster_be_pass { }
sub cluster_be_backend_fetch { }

sub cluster_be_backend_response {
    // Do not cache explicit lengths >= ~1GB in backends in general
    if (beresp.http.Content-Length ~ "^[0-9]{10}") {
	set beresp.http.X-CDIS = "pass";
        set beresp.uncacheable = true;
        return (deliver);
    }

<% if @cache_route == 'direct' or @varnish_testing -%>
    // Direct backend caches:
    // Disable streaming if no Content-Length present.  This is the default in
    // varnish3, but in varnish4 this should convert them to responses
    // containing a Content-Length in the common case, so that upper caches
    // can make size-based decisions.
    if (!beresp.http.Content-Length) {
        set beresp.do_stream = false;
    }
<% end -%>
}

sub cluster_be_deliver { }
