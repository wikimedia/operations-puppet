// Varnish VCL include file for text frontends

include "errorpage.inc.vcl";
include "text-common.inc.vcl";
include "zero.inc.vcl";
include "geoip.inc.vcl";

// Note that analytics.inc.vcl will set an X-Analytics value of proxy=IORG
// without inspecting whether there's an existing proxy=<proxy> key-
// value pair inside X-Analytics. We do this because if the traffic
// had come from a known proxy (e.g., Opera or Nokia), that would
// imply that Internet.org was not the rightmost endpoint. In time
// we will need to add the notion of proxy chaining to record whether
// something came through both a known proxy and had Via: Internet.org
// with a corresponding unknown rightmost endpoint (the rightmost
// Internet.org endpoint with an unpredictable Internet-facing IP
// address) in X-Forwarded-For, even if it's the only value, as in
// the example of traffic sourced directly by satellite or something.
// IMPORTANT NOTE: other proxy tagging isn't in place for the domains
// scoped by this text-frontend.inc.vcl.erb file, as that's currently
// only inside of zero.inc.vcl.erb, which is invoked by
// mobile-frontend.inc.vcl.erb for (m|zero).wikipedia.org and its
// subdomains.

sub mobile_redirect {
	if (!req.http.X-Subdomain && (req.request == "GET" || req.request == "HEAD")
		&& (req.http.User-Agent ~ "(?i)(mobi|240x240|240x320|320x320|alcatel|android|audiovox|bada|benq|blackberry|cdm-|compal-|docomo|ericsson|hiptop|htc[-_]|huawei|ipod|kddi-|kindle|meego|midp|mitsu|mmp\/|mot-|motor|ngm_|nintendo|opera.m|palm|panasonic|philips|phone|playstation|portalmmm|sagem-|samsung|sanyo|sec-|semc-browser|sendo|sharp|silk|softbank|symbian|teleca|up.browser|vodafone|webos)"
			|| req.http.User-Agent ~ "^(?i)(lge?|sie|nec|sgh|pg)-" || req.http.Accept ~ "vnd.wap.wml")
		&& req.http.Cookie !~ "(stopMobileRedirect=true|mf_useformat=desktop)"
		&& (
			req.url ~ "^/(wiki|(gan|ike|iu|kk|ku|shi|sr|tg|uz|zh)(-[a-z]+)?)[/\?]"
			|| req.url ~ "^/(w/index\.php)?\?title=[^&]*$"
		)) {

		// Separate regexps for clarity, but multiple regsubs instead of
		// "if host ~"/regsub matches for efficiency. Be careful to not
		// write overlapping/chaining regexps.
		set req.http.MobileHost = req.http.Host;
		set req.http.MobileHost = regsub(req.http.MobileHost, "^(www\.)?(mediawiki|wikimediafoundation|wikisource|wikidata)\.", "m.\2.");
		set req.http.MobileHost = regsub(req.http.MobileHost, "^(commons|incubator|legalteam|meta|office|outreach|pl|species|strategy|wikimania201[2-5])\.wikimedia\.", "\1.m.wikimedia.");
		set req.http.MobileHost = regsub(req.http.MobileHost, "^((?!commons|meta|nostalgia|quote|quality|sep11|sources|species|textbook|m\b)\w+)\.(wikipedia|wiktionary|wikinews|wikisource|wikiquote|wikibooks|wikiversity|wikivoyage)\.", "\1.m.\2.");

		if (req.http.Host != req.http.MobileHost) {
			if (req.http.X-Forwarded-Proto) {
				set req.http.Location = req.http.X-Forwarded-Proto + "://" + req.http.MobileHost + req.url;
			} else {
				set req.http.Location = "http://" + req.http.MobileHost + req.url;
			}
			error 666 "Found";
		}
		unset req.http.MobileHost;
	}
}

C{
	#include <string.h>
}C
sub normalize_path {
	/* Rewrite the path part of the URL, replacing unnecessarily escaped
	 * punctuation with the actual characters. The character list is from
	 * MediaWiki's wfUrlencode(), so the URLs produced here will be the same as
	 * the ones produced by MediaWiki in href attributes. Doing this reduces
	 * cache fragmentation and fixes T29935, i.e. stale cache entries due to
	 * MediaWiki purging only the wfUrlencode'd version of the URL.
	 */
	C{
		/* DIY hexadecimal conversion, since it is simple enough for a fixed
		 * width, and all the relevant standard C library functions promise to
		 * malfunction if the locale is set to anything other than "C"
		 */
		#define NP_HEX_DIGIT(c) ( \
			(c) >= '0' && (c) <= '9' ? (c) - '0' : ( \
				(c) >= 'A' && (c) <= 'F' ? (c) - 'A' + 0x0a : ( \
					(c) >= 'a' && (c) <= 'f' ? (c) - 'a' + 0x0a : -1 ) ) )
		#define NP_IS_HEX(c) (NP_HEX_DIGIT(c) != -1)
		#define NP_HEXCHAR(c1, c2) (char)( (NP_HEX_DIGIT(c1) << 4) | NP_HEX_DIGIT(c2) )
		const char * url = VRT_r_req_url(sp);
		size_t i, outPos;
		const size_t urlLength = strlen(url);
                // index for the last position %XX can start at:
		const size_t lastConvertIdx = urlLength > 2 ? urlLength - 3 : 0;
		char c;
		int dirty = 0;

		/* Allocate destination memory from the stack using the C99
		 * variable-length automatic feature. We know the length in advance
		 * because this function can only shorten the input string.
		 */
		char destBuffer[urlLength + 1];
		if (url) {
			for (i = 0, outPos = 0; i < urlLength; i++) {
				if (i <= lastConvertIdx && url[i] == '%' && NP_IS_HEX(url[i+1]) && NP_IS_HEX(url[i+2])) {
					c = NP_HEXCHAR(url[i+1], url[i+2]);
					if (c == ';'
						|| c == '@'
						|| c == '$'
						|| c == '!'
						|| c == '*'
						|| c == '('
						|| c == ')'
						|| c == ','
						|| c == '/'
						|| c == ':')
					{
						destBuffer[outPos++] = c;
						dirty = 1;
						i += 2;
					} else {
						destBuffer[outPos++] = url[i];
					}
				} else if (url[i] == '?') {
					/* Reached the query part. Just copy the rest of the URL
					 * to the destination.
					 */
					memcpy(destBuffer + outPos, url + i, sizeof(char) * (urlLength - i));
					outPos += urlLength - i;
					i = urlLength;
				} else {
					destBuffer[outPos++] = url[i];
				}
			}
			destBuffer[outPos] = '\0';

			/* Set req.url. This will copy our stack buffer into the workspace.
			 * VRT_l_req_url() is varadic, and concatenates its arguments. The
			 * vrt_magic_string_end marks the end of the list.
			 */
			if (dirty) {
				VRT_l_req_url(sp, destBuffer, vrt_magic_string_end);
			}
		}
		#undef NP_IS_HEX
		#undef NP_HEX_DIGIT
		#undef NP_HEXCHAR
	}C
}

sub vcl_recv {
	// Forged UAs on zerodot. This largely handles lazywebtools below, incidentally.
	if (req.http.host ~ "zero\.wikipedia\.org" && req.http.User-Agent && req.http.User-Agent ~ "Facebookbot|Googlebot") {
		error 403 "Noise";
	}

	if (req.http.referer && req.http.referer ~ "^http://(www\.(keeprefreshing|refreshthis|refresh-page|urlreload)\.com|tuneshub\.blogspot\.com|itunes24x7\.blogspot\.com|autoreload\.net|www\.lazywebtools\.co\.uk)/") {
		error 403 "Noise";
	}

	if (req.request == "POST" && req.url ~ "index\.php\?option=com_jce&task=plugin&plugin=imgmanager&file=imgmanager&method=form&cid=") {
		error 403 "Noise";
	}

	// FIXME: we're seeing an issue with Range requests and gzip/gunzip.
	// Disable Range requests for now.
	unset req.http.Range;

	if (req.url == "/geoiplookup" || req.http.host == "geoiplookup.wikimedia.org") {
		error 668 "geoiplookup";
	}

	if (req.restarts == 0) {
		// Always set or clear X-Subdomain and X-Orig-Cookie
		unset req.http.X-Orig-Cookie;
		unset req.http.X-Subdomain;
		unset req.http.x-dt-host; // desktop host, if mobile hostname on request

		if (req.http.host ~ "^([a-zA-Z0-9-]+\.)?zero\." && req.http.host != "zero.wikimedia.org") {
			set req.http.X-Subdomain = "ZERO";
		} else if (req.http.host ~ "^([a-zA-Z0-9-]+\.)?m\.") {
			set req.http.X-Subdomain = "M";
		}

<% if scope.function_hiera(["cluster"]) == "cache_mobile" -%>
		// mobile-cluster-only: prevent desktop/text hostnames from
		// being used here, or they'll pollute the cache for mobile
		// users.  This will never happen via our own DNS, but a user
		// could set the request hostname manually of course...
		if (!req.http.X-Subdomain && req.request != "PURGE") {
			error 418 "I'm a teapot";
		}
<% end -%>

		// mobile-subdomains-only for tag-carrier and Host-rewrite
		if (req.http.X-Subdomain) {
			// Only do tag_carrier logic on first start, and only for (m|zero).wp
			if (req.http.host ~ "^([a-zA-Z0-9-]+\.)?(m|zero)\.wikipedia\.") {
				call tag_carrier;
			}

			// Rewrite mobile hostnames to desktop hostnames as x-dt-host
			if (req.http.host == "m.mediawiki.org") {
				set req.http.x-dt-host = "www.mediawiki.org";
			} else if (req.http.host == "m.wikimediafoundation.org") {
				set req.http.x-dt-host = "wikimediafoundation.org";
			} else if (req.http.host == "m.wikisource.org") {
				set req.http.x-dt-host = "wikisource.org";
			} else if (req.http.host == "m.wikidata.org") {
				set req.http.x-dt-host = "www.wikidata.org";
			} else {
				// Replace <language>.(m|zero).<project>.org by <language>.<project>.org
				set req.http.x-dt-host = regsub(req.http.host, "^([a-zA-Z0-9-]+)\.(m|zero)\.", "\1.");
			}
<% if scope.function_hiera(["cluster"]) == "cache_mobile" -%>
			// legacy cache_mobile actually resets the real Host: header value here, cache_text does not...
			set req.http.host = req.http.x-dt-host;
<% end -%>
			if (req.url ~ "^/api/rest_v1/") {
				// for Restbase, there is no difference in desktop-vs-mobile hostnames,
				// so rewrite mobile hostnames to desktop hostnames for singular caching
				// (this affects the Host: header, and also the url rewrite for restbase
				// elsewhere that uses req.http.host)
				set req.http.host = req.http.x-dt-host;
			}
		}
	}

	// Allow purging
	call vcl_recv_purge;

	// BITS: legacy bits.wm.o domain support
	if (req.http.host == "<%= @vcl_config.fetch('bits_domain') %>") {
		if (req.url ~ "^/event\.gif") {
			error 204;
		}
		return (lookup);
	}

	// Don't decode percent-encoded slashes in paths for REST APIs
	if (req.url !~ "^/api/rest_v1/") {
		call normalize_path;
	}

	call mobile_redirect;

	# normalize all /static to the same hostname for caching
	if (req.url ~ "^/static/") { set req.http.host = "<%= @vcl_config.fetch("static_host") %>"; }

	// Users that just logged out, should not get a 304 for their
	// (locally cached) logged in pages.
	if (req.http.If-Modified-Since && req.http.Cookie ~ "LoggedOut") {
		unset req.http.If-Modified-Since;
	}

	call common_recv;

	return (lookup);
}

sub vcl_pass {
	call restore_cookie;
}

sub vcl_miss {
	call restore_cookie;
}

sub vcl_fetch {
	call common_fetch;

	return (deliver);
}

sub vcl_error {
	// BITS: legacy bits.wm.o domain support
	if (req.http.host == "<%= @vcl_config.fetch('bits_domain') %>") {
		if (obj.status == 204) {
			set obj.http.Connection = "keep-alive";
			return (deliver);
		}
	}

	// Support geoiplookup
	if (obj.status == 668) {
		call geoip_lookup;
		set obj.status = 200;
		set obj.http.Connection = "keep-alive";
		return (deliver);
	}

	// Support mobile redirects
	if (obj.status == 666) {
		set obj.http.Location = req.http.Location;
		set obj.status = 302;
		set obj.http.Connection = "keep-alive";
		set obj.http.Content-Length = "0"; // BZ #62245
		return (deliver);
	}

	call errorpage;
	return (deliver);
}

sub vcl_deliver {
	// Strip s-maxage Cache-Control of wiki pages. The s-maxage still applies to Varnish (sent
	// by MediaWiki $wgUseSquid, sends purges internally). But pages musn't be cached elsewhere.
	// NOTE: Language variants URLs are not currently covered by these regexps.
	// Instead of writing regexps for every edge-case, we should impose some order and coherence
	// on our URL routing schemes.
	// NOTE: Only apply to pages. Don't steal cachability of api.php, load.php, etc. (T102898, T113007)

	if (req.url ~ "^/wiki/" || req.url ~ "^/w/index\.php" || req.url ~ "^/\?title=") {
		// ...but exempt CentralNotice banner special pages
		if (req.url !~ "^/(wiki/|(w/index\.php)?\?title=)Special:Banner") {
			set resp.http.Cache-Control = "private, s-maxage=0, max-age=0, must-revalidate";
		}
	}

	// Perform GeoIP look-up and send the result as a session cookie
	if (req.http.X-Orig-Cookie !~ "(^|;\s*)GeoIP=[^;]"
		&& req.http.Cookie !~ "(^|;\s*)GeoIP=[^;]") {
		call geoip_cookie;
	}
}
