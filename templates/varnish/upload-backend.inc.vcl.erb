# Varnish VCL include file for upload backends

import std;

sub pick_main_stevedore {
	if (std.random(0, 2) < 1) {
		set beresp.storage = "main-sda3";
	} else {
		set beresp.storage = "main-sdb3";
	}
}

sub pick_large_object_stevedore {
	if (std.random(0, 2) < 1) {
		set beresp.storage = "bigobj-sda3";
	} else {
		set beresp.storage = "bigobj-sdb3";
	}
}

sub vcl_recv {
	/* Support HTTP PURGE from localhost */
	if (req.request == "PURGE") {
		if (!client.ip ~ purge) {
			error 405 "Denied.";
		# This is a stupid hack to make varnishhtcpd work - it's using a perl mod that sends purge reqs like
		# PURGE http://de.wikipedia.orghttp://de.wikipedia.org/w/index.php
		} elsif (req.url ~ "^http://upload.wikimedia.org") {
			set req.url = regsub ( req.url, "^http://[\w.]+(/.*)", "\1");
			return (lookup);
		} else {
			error 200 "Domain not cached here.";
		}
	}

	if (client.ip !~ wikimedia_nets) {
		error 403 "Access denied";
	}

	if ( req.http.host != "upload.wikimedia.org") {
		error 403 "Requested target domain not allowed.";
	}

	/* Make sure high range requests don't block on large objects being retrieved */
	if (req.http.Range
		&& (std.integer(regsub(req.http.Range, "^bytes=([0-9]*)-", "\1"), 0) > 33554432
			|| req.http.Range ~ "^bytes=([0-9]{9,})-")) {
		set req.hash_ignore_busy = true;
	}

	return (lookup);
}

sub vcl_fetch {
	# Cache media objects for 30 days by default
	set beresp.ttl = 30d;

	# Stream large objects, > 32 MB
	if (std.integer(beresp.http.Content-Length, 0) > 33554432 || beresp.http.Content-Length ~ "^[0-9]{9}") {
		set beresp.do_stream = true;
    }

	/* Select a random big object storage backend for objects >= 100 MB */
	if (beresp.http.Content-Length ~ "^[0-9]{9}") {
		call pick_large_object_stevedore;
	} else {
		call pick_main_stevedore;
	}
	
	if (beresp.http.Content-Range) {
		/* Varnish itself doesn't ask for ranges, so this must have been
		 * a passed range request
		 */
		set beresp.http.X-Content-Range = beresp.http.Content-Range;
	}
}

sub vcl_miss {
<% if vcl_config.fetch("cluster_tier", "1") == "1" -%>
	# Send originals to the Swift cluster
	if ( req.url ~ "^/(wikibooks|wikinews|wikiquote|wikiversity|wikimedia|wikipedia|wikisource|wiktionary)/[^/]+/(archive/)?[0-9a-f]/[0-9a-f][0-9a-f]/" ) {
		set req.backend = swift;
	# Send thumbnails to the Swift cluster
	} elsif (req.url ~ "^/+[^/]+/[^/]+/(thumb|temp)/") {
		set req.backend = swift;
	# math to swift
	} elsif (req.url ~ "^/math/") {
		set req.backend = swift;
	# timeline to swift
	} elsif (req.url ~ "^/(wikibooks|wikinews|wikiquote|wikiversity|wikimedia|wikipedia|wikisource|wiktionary)/[^/]+/timeline/") {
		set req.backend = swift;
	}
<% end -%>

	/* Convert range requests into pass when over a certain threshold */
	if (req.http.Range
		&& (std.integer(regsub(req.http.Range, "^bytes=([0-9]*)-", "\1"), 0) > 33554432
			|| req.http.Range ~ "^bytes=([0-9]{9,})-")) {
		set bereq.http.Range = req.http.Range;
		std.log("Passing high range request: " + req.http.Range);
		return (pass);
	}
}

sub vcl_deliver {
	if (resp.http.X-Content-Range) {
		set resp.http.Content-Range = resp.http.X-Content-Range;
		remove resp.http.X-Content-Range;
	}
}