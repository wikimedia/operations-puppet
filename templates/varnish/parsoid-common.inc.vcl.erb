// Varnish VCL include file shared between Parsoid front- and backends

sub cluster_recv_pre_purge {
	// Clamp the host header to 'parsoid'
	set req.http.host = "parsoid";
}

sub cluster_recv_post_purge {
	// Enable force-refresh
	// See https://www.varnish-cache.org/trac/wiki/VCLExampleEnableForceRefresh
	if (req.http.Cache-Control ~ "no-cache") {
		set req.hash_always_miss = true;
	}

	// Do not wait on concurrent (possibly actually fetching) requests for
	// only-if-cached.  One would think this could be backend-only, but it
	// needs to happen in the frontend as well for the same reason
	// (frontend stalling an only-if-cached miss fetch from the backend to
	// coalesce with a non-only-if-cached miss fetch from the backend)
	if (req.http.Cache-Control ~ "only-if-cached") {
		set req.hash_ignore_busy = true;
		return (lookup);  // skip default vcl_recv which can generate
		                  // pass in some cases...
	}

	// --------------------------------------------------------------------
	// This is the varnish default vcl_recv code, copied here so that
	// cache_parsoid matches all the other clusters' behavior in that it
	// doesn't rely on implicit invocation of the default vcl_recv after
	// returning from its custom recv code...

	if (req.restarts == 0) {
		if (req.http.x-forwarded-for) {
			set req.http.X-Forwarded-For = req.http.X-Forwarded-For + ", " + client.ip;
		}
		else {
			set req.http.X-Forwarded-For = client.ip;
		}
	}

	if (req.request != "GET" &&
	    req.request != "HEAD" &&
	    req.request != "PUT" &&
	    req.request != "POST" &&
	    req.request != "TRACE" &&
	    req.request != "OPTIONS" &&
	    req.request != "DELETE") {
		/* Non-RFC2616 or CONNECT which is weird. */
		return (pipe);
	}

	if (req.request != "GET" && req.request != "HEAD") {
		/* We only deal with GET and HEAD by default */
		return (pass);
	}

	if (req.http.Authorization || req.http.Cookie) {
		/* Not cacheable by default */
		return (pass);
	}

	return (lookup);
}
