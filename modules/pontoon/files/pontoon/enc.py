#!/usr/bin/python3
# SPDX-License-Identifier: Apache-2.0
import argparse
import logging
import os
import sys
import fcntl

from pontoon import Pontoon

from ruamel.yaml import YAML

log = logging.getLogger()


def update_hiera(pontoon, config_path, hiera_path):
    """Output Hiera values for this Pontoon stack."""
    config_mtime = os.stat(config_path).st_mtime
    hiera_mtime = -1
    if os.path.exists(hiera_path):
        hiera_mtime = os.stat(hiera_path).st_mtime

    # Update only as needed, not at every ENC run
    if config_mtime < hiera_mtime:
        return

    with open(hiera_path, "w") as f:
        try:
            fcntl.flock(f, fcntl.LOCK_EX)
            YAML().dump(pontoon.role_variables(), f)
            f.flush()
        finally:
            fcntl.flock(f, fcntl.LOCK_UN)


def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(
        description="Pontoon ENC",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "hostname",
        type=str,
        default=None,
        nargs="?",
        help="The hostname to return data for",
    )
    parser.add_argument(
        "--pontoon.home",
        type=str,
        metavar="PATH",
        dest="pontoon_home",
        default=os.environ.get(
            "PONTOON_HOME", "/srv/git/operations/puppet/modules/pontoon/files"
        ),
        help="The path where to find stacks (env: PONTOON_HOME)",
    )
    parser.add_argument(
        "--stack.file",
        type=str,
        metavar="PATH",
        dest="stack_file",
        default=os.environ.get("PONTOON_STACK_FILE", "/etc/pontoon/stack"),
        help="File with the Pontoon stack name (env: PONTOON_STACK_FILE)",
    )
    parser.add_argument(
        "--hiera.output",
        type=str,
        default="/etc/pontoon/hiera/auto.yaml",
        metavar="PATH",
        dest="hiera_output",
        help="Destination PATH for autogenerated hiera configuration",
    )
    parser.add_argument(
        "--list-hosts",
        default=False,
        dest="list_hosts",
        action="store_true",
        help="Print all hosts in this stack",
    )
    args = parser.parse_args()

    stack = None
    if os.path.exists(args.stack_file):
        with open(args.stack_file) as f:
            stack = f.readline().strip()

    if stack is None:
        stack = os.environ.get("PONTOON_STACK")

    if stack is None:
        parser.error(
            f"Unable to determine stack. Tried {args.stack_file} and PONTOON_STACK."
        )

    p = Pontoon(stack, args.pontoon_home)

    if args.list_hosts:
        for host in sorted(p.host_map().keys()):
            print(host)
        return 0

    if args.hiera_output:
        # Autogenerate hiera variables from Pontoon's rolemap. These variables can be referenced in
        # hiera itself via %{alias('variable')}
        update_hiera(p, p.rolemap_path, args.hiera_output)

    role = p.role_for_host(args.hostname)
    if not role:
        log.error("Host %s not found in %s", args.hostname, p.rolemap_path)
        sys.exit(-1)

    variables = {
        # role() emulation
        "_role": role.replace("::", "/"),
    }

    YAML().dump(
        {
            "classes": ["role::%s" % role, "profile::pontoon::base"],
            "parameters": variables,
        },
        sys.stdout,
    )


if __name__ == "__main__":
    sys.exit(main())
