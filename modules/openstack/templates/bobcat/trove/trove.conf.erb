# SPDX-License-Identifier: Apache-2.0

[DEFAULT]
# Show debugging output in logs (sets DEBUG log level output)
debug = True

# Address to bind the API server
bind_host = ::

# Port the bind the API server to
bind_port = <%= @api_bind_port %>

# Number of workers for the API service. The default will
# be the number of CPUs available. (integer value)
trove_api_workers = <%= @workers %>
trove_conductor_workers = <%= @workers %>

# Inject a public key into each DB instance for debug purposes
nova_keypair='trove-debug'

use_syslog = True
use_json = True
syslog_log_facility = LOG_LOCAL0


# In theory trove supports volume resize without stopping the DB. In practice
#  this resizes the volume but the mountpoint doesn't pick up the change.
#
# Setting this to False means a service interruption during resize but the
#  resize actually works thanks to detaching/reattaching the volume.
online_volume_resize = False


#===================== RPC Configuration =================================

# URL representing the messaging driver to use and its full configuration.
# If not set, we fall back to the 'rpc_backend' option and driver specific
# configuration.
transport_url = rabbit://<%= @rabbitmq_nodes.map{ |rabbit_host| "#{@rabbit_user}:#{@rabbit_pass}\@#{rabbit_host}:5671" }.join(',') %>

# The default exchange under which topics are scoped. May be
# overridden by an exchange name specified in the 'transport_url option.
control_exchange = trove

# Maximum line size of message headers to be accepted.
# max_header_line may need to be increased when using large tokens
# (typically those generated by the Keystone v3 API with big service
# catalogs)
# max_header_line = 16384

#DB Api Implementation
db_api_implementation = "trove.db.sqlalchemy.api"

# Configuration options for talking to nova via the novaclient.

# Service type to use when searching catalog.
#nova_compute_service_type = compute

# Service type to use when searching catalog.
#swift_service_type = object-store

# Service type to use when searching catalog.
#neutron_service_type = network

# Config option for showing the IP address that nova doles out
# For nova-network, set this to the appropriate network label defined in nova
# For neutron, set this to .* since users can specify custom network labels
# You can also optionally specify regex'es to match the actual IP addresses
# ip_regex (white-list) is applied before black_list_regex in the filter chain
#ip_regex = ^(15.|123.)
#black_list_regex = ^10.0.0.

# Config options for enabling volume service
trove_volume_support = True
block_device_mapping = vdb
device_path = /dev/vdb
# Maximum volume size for an instance


max_accepted_volume_size = 2048
max_instances_per_tenant = 10
# Maximum volume capacity (in GB) spanning across all trove volumes per tenant
max_volumes_per_tenant = 10
max_backups_per_tenant = 2
volume_time_out=30

# Config options for rate limits
http_get_rate = 200
http_post_rate = 200
http_put_rate = 200
http_delete_rate = 200
http_mgmt_post_rate = 200

# Trove DNS
trove_dns_support = True
dns_account_id = <%= @trove_service_project %>
dns_auth_url = https://<%= @keystone_fqdn %>:25000
dns_username = <%= @trove_service_user %>
dns_passkey = <%= @trove_service_user_pass %>
dns_ttl = 300
dns_domain_name = <%= @trove_dns_zone %>
dns_domain_id = <%= @trove_dns_zone_id %>
dns_driver = trove.dns.designate.driver.DesignateDriverV2
dns_instance_entry_factory = trove.dns.designate.driver.DesignateInstanceEntryFactory
dns_endpoint_url = <%= @designate_internal_uri %>
dns_service_type = dns

# Neutron
network_driver = trove.network.neutron.NeutronDriver
management_networks =


# Taskmanager queue name
taskmanager_queue = taskmanager

# Auth
admin_roles = admin

# Guest related conf
agent_heartbeat_time = 10
agent_call_low_timeout = 5
agent_call_high_timeout = 150

# Allow a good long time to format volumes so that we support big volumes.
# The default here is 120 seconds which limits us to 30GB volumes.
volume_format_timeout = 10800
usage_timeout = 10800

# Reboot time out for instances
reboot_time_out = 60

# Trove api-paste file name
api_paste_config = api-paste.ini

auth_strategy = keystone
add_addresses = True

taskmanager_manager = trove.taskmanager.manager.Manager

# Inject configuration into guest via ConfigDrive
use_nova_server_config_drive = True

# Set these if using Neutron Networking
network_driver=trove.network.neutron.NeutronDriver


# ============ Notification System configuration ===========================

# Sets the notification driver used by oslo.messaging. Options include
# messaging, messagingv2, log and routing. Default is 'noop'
# notification_driver=noop

# Topics used for OpenStack notifications, list value. Default is 'notifications'.
# notification_topics=notifications

# ============ Logging information =============================
#log_dir = /integration/report
#log_file = trove-api.log


<%= scope.call_function('template', ["openstack/#{@version}/common/database.erb"]) %>

[profiler]
# If False fully disable profiling feature.
#enabled = False
# If False doesn't trace SQL requests.
#trace_sqlalchemy = True

[ssl]

#cert_file = /path/to/server.crt
#key_file = /path/to/server.key
#optional:
#ca_file = /path/to/ca_file

[oslo_messaging_notifications]

#
# From oslo.messaging
#

# The Driver(s) to handle sending notifications. Possible
# values are messaging, messagingv2, routing, log, test, noop
# (multi valued)
# Deprecated group/name - [DEFAULT]/notification_driver
#driver =

# A URL representing the messaging driver to use for
# notifications. If not set, we fall back to the same
# configuration used for RPC. (string value)
# Deprecated group/name - [DEFAULT]/notification_transport_url
#transport_url = <None>

# AMQP topic used for OpenStack notifications. (list value)
# Deprecated group/name - [rpc_notifier2]/topics
# Deprecated group/name - [DEFAULT]/notification_topics
#topics = notifications

# The maximum number of attempts to re-send a notification
# message which failed to be delivered due to a recoverable
# error. 0 - No retry, -1 - indefinite (integer value)
#retry = -1

<%= scope.call_function('template', ["openstack/#{@version}/common/oslo_messaging_rabbit.erb"]) %>

[mysql]
root_on_create = False
# Format (single port or port range): A, B-C
# where C greater than B
tcp_ports = 3306
volume_support = True
device_path = /dev/vdb

# Users to ignore for user create/list/delete operations
ignore_users = os_admin, root
ignore_dbs = mysql, information_schema, performance_schema

[mariadb]
root_on_create = False
# Format (single port or port range): A, B-C
# where C greater than B
tcp_ports = 3306
volume_support = True
device_path = /dev/vdb

# Users to ignore for user create/list/delete operations
ignore_users = os_admin, root
ignore_dbs = mysql, information_schema, performance_schema

[postgresql]
tcp_ports = 5432
volume_support = True
device_path = /dev/vdb

[redis]
tcp_ports = 6379, 16379
volume_support = True
device_path = /dev/vdb

[cassandra]
tcp_ports = 7000, 7001, 9042, 9160
volume_support = True
device_path = /dev/vdb

[couchbase]
tcp_ports = 8091, 8092, 4369, 11209-11211, 21100-21199
volume_support = True
device_path = /dev/vdb

[mongodb]
tcp_ports = 2500, 27017, 27019
volume_support = True
device_path = /dev/vdb
num_config_servers_per_cluster = 1
num_query_routers_per_cluster = 1

[vertica]
tcp_ports = 5433, 5434, 22, 5444, 5450, 4803
udp_ports = 5433, 4803, 4804, 6453
volume_support = True
device_path = /dev/vdb
cluster_support = True
cluster_member_count = 3
api_strategy = trove.common.strategies.cluster.experimental.vertica.api.VerticaAPIStrategy


# ============ CORS configuration =============================

[cors]

#
# From oslo.middleware.cors
#

# Indicate whether this resource may be shared with the domain received in the
# requests "origin" header. (list value)
#allowed_origin = <None>

# Indicate that the actual request can include user credentials (boolean value)
#allow_credentials = true

# Indicate which headers are safe to expose to the API. Defaults to HTTP Simple
# Headers. (list value)
#expose_headers = X-Auth-Token, X-Subject-Token, X-Service-Token, X-OpenStack-Request-ID

# Maximum cache age of CORS preflight requests. (integer value)
#max_age = 3600

# Indicate which methods can be used during the actual request. (list value)
#allow_methods = GET,PUT,POST,DELETE,PATCH

# Indicate which header field names may be used during the actual request.
# (list value)
#allow_headers = X-Auth-Token, X-Identity-Status, X-Roles, X-Service-Catalog, X-User-Id, X-Tenant-Id, X-OpenStack-Request-ID


[cors.subdomain]

#
# From oslo.middleware.cors
#

# Indicate whether this resource may be shared with the domain received in the
# requests "origin" header. (list value)
#allowed_origin = <None>

# Indicate that the actual request can include user credentials (boolean value)
#allow_credentials = true

# Indicate which headers are safe to expose to the API. Defaults to HTTP Simple
# Headers. (list value)
#expose_headers = X-Auth-Token, X-Subject-Token, X-Service-Token, X-OpenStack-Request-ID

# Maximum cache age of CORS preflight requests. (integer value)
#max_age = 3600

# Indicate which methods can be used during the actual request. (list value)
#allow_methods = GET,PUT,POST,DELETE,PATCH

# Indicate which header field names may be used during the actual request.
# (list value)
#allow_headers = X-Auth-Token, X-Identity-Status, X-Roles, X-Service-Catalog, X-User-Id, X-Tenant-Id, X-OpenStack-Request-ID

[oslo_middleware]

#
# From oslo.middleware
#

# Whether the application is behind a proxy or not. This determines if the
# middleware should parse the headers or not. (boolean value)
#enable_proxy_headers_parsing = false


[oslo_policy]
enforce_scope = <%= @enforce_policy_scope %>
enforce_new_defaults = <%= @enforce_new_policy_defaults %>
policy_file = policy.yaml

<%= scope.call_function('template', ["openstack/#{@version}/common/keystone_authtoken.erb"]) %>

[service_credentials]
auth_url = https://<%= @keystone_fqdn %>:25000
region_name = <%= @region %>
project_name = <%= @trove_service_project %>
password = <%= @trove_service_user_pass %>
project_domain_name = Default
user_domain_name = Default
username = <%= @trove_service_user %>


[network]
# Options related to the trove instance networking.

#
# From trove.config
#

# ID of the Neutron public network to create floating IP for the public trove instance. If not given, Trove will try to query all the public
# networks and use the first one in the list. (string value)
#public_network_id = <None>

# Check if the user provided network is associated with router. This is needed for the instance initialization. The check is also necessary
# when creating public facing instance. A scenario to set this option False is when using Neutron provider network. (boolean value)
enable_access_check = False
