#!/usr/bin/python

import os
import socket
import sys

# Check that we are passed the tool name and an executable
# to call.
if len(sys.argv) <= 2:
    sys.stderr.write('Usage: portgrabber TOOLNAME EXECUTABLE [ARGUMENTS...]\n')
    sys.stderr.write('\n')
    sys.stderr.write('portgrabber requests a free port number for TOOLNAME and then\n')
    sys.stderr.write('calls EXECUTABLE [ARGUMENTS...] PORT.\n')
    sys.exit(1)

# Set tool name.
tool = sys.argv[1]

# Connect to local portgranter instance and receive a (hopefully)
# unallocated port number.
s = socket.socket(socket.AF_UNIX)
s.connect('/tmp/sock.portgranter')
f = s.makefile('r+', 0)
f.write(tool + '\n')
port = f.readline().rstrip()

# Connect to the proxylistener instances on the web proxies and notify
# them where requests for the tool need to be routed to.
proxies = ('tools-webproxy-01', 'tools-webproxy-02')
socks = []
for proxy in proxies:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((proxy, 8282))
    sock.sendall(".*\nhttp://%s:%s\n" % (socket.getfqdn(), port))
    socks.append(sock)

# Execute the program with the optional arguments and the port number
# appended.  The sockets are passed on to the program so that they are
# closed when the program terminates.
os.execvp(sys.argv[2], sys.argv[2:] + [port])
