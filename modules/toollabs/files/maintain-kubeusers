#!/usr/bin/python3
"""
Source of canonical truth is the tokenauth.csv file. 


 - Get a list of all the users from LDAP
 - Load the current file
 - Do a diff, find new users
 - Add them to file, and also add them to:
   - .kube/config on the user's homedir
   - abac.json for access config
   - create the namespace with appropriate annotation
"""
import logging
import argparse
import ldap3
import yaml
import json
import subprocess
import os
import string
import random
import time
import csv

TOOL_ALLOWED_RESOURCES = [
    'pods',
    'replicationcontrollers',
    'services',
    'secrets',
    'deployments',
    'replicasets',
    'configmaps'
]


class User:
    def __init__(self, name, id, token=None, group='tool'):
        """
        'group' can be on of 'tool', 'infrastructure-readwrite' or 'infrastructure-readonly'
        """
        self.name = name
        self.id = id
        self.token = token
        self.group = group


def generate_pass(length):
    """
    Generate a secure password of given length
    """
    password_chars = string.ascii_letters + string.digits
    sysrandom = random.SystemRandom()  # Uses /dev/urandom
    return ''.join([sysrandom.choice(password_chars) for _ in range(length)])


def get_users_from_csv(path):
    """
    Builds list of users from a CSV file
    """
    users = {}
    with open(path) as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            user = User(row[1], row[2], row[0])
            if len(row) > 3:
                user.group = row[3]  # Use 'group' field to set type
            users[user.id] = user

    return users


def get_tools_from_ldap(conn, projectname):
    """
    Builds list of all tools from LDAP
    """
    conn.search(
        'ou=people,ou=servicegroups,dc=wikimedia,dc=org',
        '(cn=%s.*)' % projectname,
        ldap3.SEARCH_SCOPE_WHOLE_SUBTREE,
        attributes=['uidNumber', 'cn']
    )
    tools = {}
    for resp in conn.response:
        attrs = resp['attributes']
        tool = User(
            attrs['cn'][0][len(projectname) + 1:],
            attrs['uidNumber'][0],
            group='tool'
        )
        tools[tool.id] = tool

    return tools


def write_tokenauth(users, path):
    """
    Write a tokenauth file for given list of users

    See http://kubernetes.io/docs/admin/authentication/ for info
    on format of the tokenauth file.
    """
    with open(path, 'w') as f:
        writer = csv.writer(f)
        for user in users:
            writer.writerow((
                user.token,
                user.name,
                user.id,
                user.group
            ))


def write_abac(users, path):
    """
    Write ABAC file for authorization of users and resources they can access

    See http://kubernetes.io/docs/admin/authorization/ for info on format
    of the ABAC file
    """
    with open(path, 'w') as f:
        # This allows access to nonResourcePaths, such as version info & swagger spec
        # This is required for kubectl to work with its default settings (primarily for validation)
        f.write(json.dumps({
            "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
            "kind": "Policy",
            "spec": {
                "user": "*",
                "nonResourcePath": "*",
                "readonly": True
            }
        }) + "\n")
        for user in users:
            if user.group == 'tool':
                rules = [{
                    "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
                    "kind": "Policy",
                    "spec": {
                        "user": user.name,
                        "namespace": user.name,
                        "resource": resource,
                        "apiGroup": "*"
                    }
                } for resource in TOOL_ALLOWED_RESOURCES]
            elif user.group == 'infrastructure-readonly':
                rules = [{
                    "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
                    "kind": "Policy",
                    "spec": {
                        "user": user.name,
                        "namespace": "*",
                        "resource": "*",
                        "apiGroup": "*",
                        "readonly": True
                    }
                }]
            elif user.group == 'infrastructure-readwrite':
                rules = [{
                    "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
                    "kind": "Policy",
                    "spec": {
                        "user": user.name, 
                        "namespace": "*",
                        "resource": "*",
                        "apiGroup": "*"
                    }
                }]
            else:
                raise Exception(
                    'User {tool} has unknown group {group}'.format(tool=user.name, group=user.group)
                )
            for rule in rules:
                f.write(json.dumps(rule) + '\n')


def write_kubeconfig(user, master):
    """
    Write an appropriate .kube/config for given user to access given master

    See http://kubernetes.io/docs/user-guide/kubeconfig-file/ for format
    """
    config = {
        'apiVersion': 'v1',
        'kind': 'Config',
        'clusters': [{
            'cluster': {
                'server': master
            },
            'name': 'default'
        }],
        'users': [{
            'user': {
                'token': user.token,
            },
            'name': user.name,
        }],
        'contexts': [{
            'context': {
                'cluster': 'default',
                'user': user.name,
                'namespace': user.name,
            },
            'name': 'default'
        }],
        'current-context': 'default'
    }
    dirpath = os.path.join('/data', 'project', user.name, '.kube')
    path = os.path.join(dirpath, 'config')
    os.makedirs(dirpath, exist_ok=True)
    f = os.open(path, os.O_CREAT | os.O_WRONLY | os.O_NOFOLLOW)
    try:
        os.write(f, json.dumps(config, indent=4, sort_keys=True).encode('utf-8'))
        # uid == gid
        os.fchown(f, int(user.id), int(user.id))
        os.fchmod(f, 0o400)
        logging.info('Write config in %s', path)
    except:
        logging.exception()
        raise
    finally:
        os.close(f)


def create_namespace(user):
    """
    Creates a namespace for the given user if it doesn't exist
    """
    p = subprocess.Popen([
        '/usr/local/bin/kubectl',
        'create',
        '-f', 
        '-'
    ], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    namespace = {
        "kind": "Namespace",
        "apiVersion": "v1",
        "metadata": {
            "name": user.name,
            "labels": {
                "name": user.name
            },
            "annotations": {
                "RunAsUser": str(user.id)
            }
        }
    }
    logging.info(p.communicate(json.dumps(namespace).encode()))

if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('--ldapconfig', help='Path to YAML LDAP config file',
                           default='/etc/ldap.yaml')
    argparser.add_argument('--infrastructure-users',
                           help='Path to CSV file with infrastructure users config (tokenauth format)',
                           default='/etc/kubernetes/infrastructure-users.csv')
    argparser.add_argument('--debug', help='Turn on debug logging',
                           action='store_true')
    argparser.add_argument('--project', help='Project name to fetch LDAP users from',
                           default='tools')
    argparser.add_argument('--interval', help='Seconds between between runs',
                           default=300)
    argparser.add_argument('--once', help='Run once and exit',
                           action='store_true')
    argparser.add_argument('kube_master_url', help='Full URL of Kubernetes Master')
    argparser.add_argument('tokenauth_output_path', help='Path to output tokenauth CSV file')
    argparser.add_argument('abac_output_path', help='Path to output abac JSONL file')

    args = argparser.parse_args()

    loglvl = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(format='%(message)s', level=loglvl)

    with open(args.ldapconfig) as f:
        ldapconfig = yaml.safe_load(f)

    cur_users = get_users_from_csv(args.tokenauth_output_path)

    infra_users = get_users_from_csv(args.infrastructure_users)

    while True:
        logging.info('starting a run')
        server = ldap3.Server(ldapconfig['servers'][0])  # FIXME: add failover support
        with ldap3.Connection(
            server, read_only=True,
            user=ldapconfig['user'],
            auto_bind=True,
            password=ldapconfig['password']
        ) as conn:
            tools = get_tools_from_ldap(conn, args.project)

        new_tools = set(tools).union(set(infra_users)) - set(cur_users)
        if len(new_tools) > 0:
            # There are at least some new tools, so we have to:
            #  1. Regenerate the entire tokenauth file
            #  2. Regenerate entire ABAC file
            #  3. Writ eout kubeconfig files for all the new tools
            #  4. Restart the apiserver
            for nt in new_tools:
                if nt in tools:
                    tools[nt].token = generate_pass(64)
                    write_kubeconfig(tools[nt], args.kube_master_url)
                    create_namespace(tools[nt])
            all_users = list(tools.values()) + list(infra_users.values())
            write_tokenauth(all_users, args.tokenauth_output_path)
            write_abac(all_users, args.abac_output_path)
            subprocess.check_call([
                '/usr/bin/sudo',
                '/bin/systemctl',
                'restart',
                'kube-apiserver'
            ])
            cur_users = all_users
        logging.info('finished run')

        if args.once:
            break

        time.sleep(args.interval)
