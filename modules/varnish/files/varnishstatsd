#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  varnishstatsd
  ~~~~~~~~~~~~~
  Report backend response times and request counts aggregated by status.

  Copyright 2015 Ori Livneh <ori@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
import argparse
import collections
import socket
import urlparse
from varnishlog import varnishlog


sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)


def parse_statsd_server_string(server_string):
    parsed = urlparse.urlparse('//' + server_string)
    return parsed.hostname, parsed.port or 8125

ap = argparse.ArgumentParser(
    description='Varnish backend response time metric logger',
    epilog='If no statsd server is specified, prints stats to stdout instead.'
)
ap.add_argument('--varnish-name', help='varnish name')
ap.add_argument('--statsd-server', help='statsd server',
                type=parse_statsd_server_string, default=None)
ap.add_argument('--key-prefix', help='metric key prefix',
                default='varnish.backends')
args = ap.parse_args()

vsl_args = [
    ('i', 'Backend'),
    ('i', 'BackendXID'),
    ('i', 'TxRequest'),
    ('i', 'RxStatus'),
    ('i', 'ReqEnd'),
]

if args.varnish_name:
    vsl_args.append(('n', args.varnish_name))

# Maximum number of log records to keep in memory.
MAX_BACKLOG = 1000

# Map of transaction ID: request method ('GET', 'POST', etc.)
tids = collections.OrderedDict()

# Map of backend XID: transaction ID
xids = collections.OrderedDict()

# Map of transaction ID: backend name
backends = collections.OrderedDict()

# Map of transaction ID: response status code (200, 404, etc.)
statuses = collections.OrderedDict()

stats = []


def vsl_callback(transaction_id, tag, record, remote_party):
    global stats

    if tag == 'Backend':
        # Associate the transaction ID with the backend name.
        tid, _, backend = record.split()
        backends[int(tid)] = backend
        if len(backends) > MAX_BACKLOG:
            backends.popitem(last=False)

    elif tag == 'BackendXID':
        # Associate the backend XID with its transaction ID.
        xids[record] = transaction_id
        if len(xids) > MAX_BACKLOG:
            xids.popitem(last=False)

    elif tag == 'TxRequest' and remote_party == 'backend':
        # Associate the transaction ID with the request method.
        tids[transaction_id] = record
        if len(tids) > MAX_BACKLOG:
            tids.popitem(last=False)

    elif tag == 'RxStatus' and remote_party == 'backend':
        # Associate the transaction ID with the response status code.
        statuses[transaction_id] = record[0] + 'xx'
        if len(statuses) > MAX_BACKLOG:
            statuses.popitem(last=False)

    elif tag == 'ReqEnd':
        # Collate data and emit metric.
        fields = record.split()
        xid = fields[0]

        try:
            tid = xids.pop(xid)
            method = tids.pop(tid)
            backend = backends.pop(tid)
            status = statuses.pop(tid)
        except KeyError:
            return 0

        ttfb = round(1000 * float(fields[4]))
        stats.extend((
            '%s.%s.%s:%d|ms' % (args.key_prefix, backend, method, ttfb),
            '%s.%s.%s:1|c' % (args.key_prefix, backend, status),
        ))

        if not args.statsd_server:
            while stats:
                print(stats.pop())
        elif len(stats) >= BATCH_SIZE:
            stats_dgram = '\n'.join(stats).encode('utf-8')
            sock.sendto(stats_dgram, args.statsd_server)
            del stats[:]

    return 0

varnishlog(vsl_args, vsl_callback)
