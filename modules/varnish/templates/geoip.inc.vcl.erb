// Varnish VCL include file

// Note: This requires "import header" in the including VCL

C{
    #include <dlfcn.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <maxminddb.h>
    #include <pthread.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
    #include <arpa/inet.h>
    #include <alloca.h>
    #include <syslog.h>

    MMDB_s* mmdb = NULL;
    #define GEO_FILE "/usr/share/GeoIP/GeoIP2-City.mmdb"
}C

// This loads a fresh MaxMind DB on every VCL reload, but does not check for
// data updates between reloads (which would require complex locking or a
// URCU-based scheme like netmapper uses.  Better to save this for future move
// to a vmod post-varnish4)
sub vcl_init { C{
    mmdb = malloc(sizeof(*mmdb));
    int st = MMDB_open(GEO_FILE, MMDB_MODE_MMAP, mmdb);
    if (st != MMDB_SUCCESS) {
        free(mmdb);
        mmdb = NULL;
        syslog(LOG_CRIT, "geoip.inc.vcl: failed to load MMDB '%s'", GEO_FILE);
    }
}C }

// This de-allocates MMDB resources when a VCL is actually discarded, which may
// be a long while after the triggering reload, especially on low-traffic
// clusters.
sub vcl_fini { C{
    if (mmdb) {
        MMDB_close(mmdb);
        free(mmdb);
        mmdb = NULL;
    }
}C }

// runtime stuff
C{
    /*
     * This function sanitizes the contents of the X-Client-IP header into the
     * pre-allocated buffer at "ip".  It will write at most INET6_ADDRSTRLEN
     * characters to "ip" including the (always present) terminal NUL.  The
     * return value is the zero for success, non-zero for failure (input IP is
     * invalid or the encoding of it is too long).
     */
<% if @varnish_version4 -%>
    static int geo_get_xcip(const struct vrt_ctx *ctx, char* ip) {
        const struct gethdr_s hdr = { HDR_REQ, "\014X-Client-IP:" };
        const char* client_ip = VRT_GetHdr(ctx, &hdr);
<% else -%>
    static int geo_get_xcip(const struct sess* sp, char* ip) {
        const char* client_ip = VRT_GetHdr(sp, HDR_REQ, "\014X-Client-IP:");
<% end -%>
        size_t len = 0;
        int rv = -1;

        if (client_ip) {
            len = strspn(client_ip, "1234567890abcdefABCDEF.:");
            if (len > 0 && len < INET6_ADDRSTRLEN) {
                memcpy(ip, client_ip, len);
                ip[len] = '\0';
                rv = 0;
            }
        }

        return rv;
    }

    /*
     * Make a string safe to use as a cookie value in a Set-Cookie header by
     * replacing CTLs, DEL, 8-bit characters, space, double-quote, comma,
     * semicolon, and backslash with an underscore.
     */
    static void geo_sanitize_for_cookie(char* p) {
        while(*p) {
            if (*p < 0x21 || *p > 0x7E || strchr("\",;\\", *p))
                *p = '_';
            p++;
        }
    }

    /*
     * Extract the topmost part of the domain name for which a cookie may be
     * set.  This consists of the public suffix (e.g., 'org') plus one more
     * level.
     *
     * In Wikimedia's case, this is always the top two parts of the name (for
     * example, 'wikipedia.org' for 'en.m.wikipedia.org'. But we handle other
     * common cases correctly too, like 'news.bbc.co.uk' (which may set cookies
     * for bbc.co.uk, but not the entire co.uk public suffix), by assuming that
     * if either of the top two levels is less than three characters long, then
     * the public suffix contains two parts. A fully comprehensive and correct
     * solution would require checking against a public suffix database like
     * <https://publicsuffix.org/>.
     */
    static const char* geo_get_top_cookie_domain(const char* host) {
        const char *last, *second_last, *third_last, *pos, *top_cookie_domain;

        if (!host)
            return NULL;

        last = second_last = third_last = host;
        for (pos = host; *pos != '\0'; pos++) {
            if (*pos == '.') {
                third_last = second_last;
                second_last = last;
                last = pos;
            }
        }

        // If either the second- or top-level domain is less than three
        // characters long, assume that the domain uses a two-part public
        // suffix (like '.co.uk') and include one additional level in the
        // result.  Also, if the name ends in '.beta.wmflabs.org', make a
        // special case for that.
        if (!strcmp(third_last, ".beta.wmflabs.org")
                || (pos - last) <= 3
                || (last - second_last) <= 3) {
            top_cookie_domain = third_last;
        } else {
            top_cookie_domain = second_last;
        }

        if (*top_cookie_domain == '.')
            top_cookie_domain++;

        return top_cookie_domain;
    }

    typedef enum _geo_idx_t {
        GEO_IDX_CITY    = 0,
        GEO_IDX_COUNTRY = 1,
        GEO_IDX_REGION  = 2,
        GEO_IDX_LAT     = 3,
        GEO_IDX_LON     = 4,
        _GEO_IDX_SIZE   = 5,
    } geo_idx_t;

<% if @varnish_version4 -%>
    static void geo_out_cookie(const struct vrt_ctx *ctx, char** geo) {
<% else -%>
    static void geo_out_cookie(struct sess* sp, char** geo) {
<% end -%>
        char host_safe[50];

        // We can't set a cookie if we don't know the valid top domain, so this
        // is the case where we emit no Cookie output at all (as before) with
        // the two possible bare "return;" below
<% if @varnish_version4 -%>
        const struct gethdr_s hdr = { HDR_REQ, "\005host:" };
        const char* host = VRT_GetHdr(ctx, &hdr);
<% else -%>
        const char* host = VRT_GetHdr(sp, HDR_REQ, "\005host:");
<% end -%>
        if (!host)
            return;
        const char* top_dom = geo_get_top_cookie_domain(host);
        const unsigned top_dom_len = strlen(top_dom);
        if (top_dom_len >= 50)
            return;
        memcpy(host_safe, top_dom, top_dom_len + 1);
        geo_sanitize_for_cookie(host_safe);

        char out[255];
        int out_size = snprintf(out, 255, "GeoIP=%s:%s:%s:%s:%s:v4",
            geo[GEO_IDX_COUNTRY],
            geo[GEO_IDX_REGION],
            geo[GEO_IDX_CITY],
            geo[GEO_IDX_LAT],
            geo[GEO_IDX_LON]
        );

        if (out_size >= 254)
            strcpy(out, "GeoIP=:::::v4");
        else
            geo_sanitize_for_cookie(out);

        // Use libvmod-header to ensure the Set-Cookie header we are adding
        // does not clobber or manipulate existing cookie headers (if any).
<% if @varnish_version4 -%>
        const struct gethdr_s hdr_set_cookie = { HDR_RESP, "\013Set-Cookie:" };
        Vmod_header_Func.append(ctx, &hdr_set_cookie,
                                out, "; Path=/; secure; Domain=.",
                                host_safe, vrt_magic_string_end);
<% else -%>
        Vmod_Func_header.append(sp, HDR_RESP, "\013Set-Cookie:",
                                out, "; Path=/; secure; Domain=.",
                                host_safe, vrt_magic_string_end);
<% end -%>
    }

    static const char* mm_path[_GEO_IDX_SIZE][4] = {
        {"city", "names", "en", NULL},
        {"country", "iso_code", NULL, NULL},
        {"subdivisions", "0", "iso_code", NULL},
        {"location", "latitude", NULL, NULL},
        {"location", "longitude", NULL, NULL},
    };

<% if @varnish_version4 -%>
    static void geo_xcip_output(const struct vrt_ctx *ctx) {
<% else -%>
    static void geo_xcip_output(struct sess* sp) {
<% end -%>
        int gai_error, mmdb_error;
        char ip[INET6_ADDRSTRLEN];
        char* geo[_GEO_IDX_SIZE];
        char* empty = "\0";
        geo_idx_t g;

        // Initialize geo to all-empty early, for failure output
        for (g = 0; g < _GEO_IDX_SIZE; g++)
            geo[g] = empty;

        if (!mmdb)
            goto out;
<% if @varnish_version4 -%>
        if (geo_get_xcip(ctx, ip))
<% else -%>
        if (geo_get_xcip(sp, ip))
<% end -%>
            goto out;
        MMDB_lookup_result_s result = MMDB_lookup_string(mmdb, ip,
            &gai_error, &mmdb_error);
        if (gai_error || mmdb_error != MMDB_SUCCESS || !result.found_entry)
            goto out;

        // from this point we have a lookup, it just may or may
        // not have a full set of useful fields.

        // Parse results into "geo" on the stack, which is always full of
        // pointers.  The pointers are to empty strings if results are lacking.
        for (g = 0; g < _GEO_IDX_SIZE; g++) {
            MMDB_entry_data_s edata;
            int st = MMDB_aget_value(&result.entry, &edata, mm_path[g]);
            if (st == MMDB_SUCCESS && edata.has_data) {
                switch(edata.type){
                    case MMDB_DATA_TYPE_UTF8_STRING:
                        geo[g] = alloca(edata.data_size + 1);
                        memcpy(geo[g], edata.utf8_string, edata.data_size);
                        geo[g][edata.data_size] = '\0';
                        break;
                    case MMDB_DATA_TYPE_DOUBLE:
                        geo[g] = alloca(16);
                        snprintf(geo[g], 16, "%.2f", edata.double_value);
                        break;
                    default:
                        break;
                }
            }
        }

        out:
<% if @varnish_version4 -%>
        geo_out_cookie(ctx, geo);
<% else -%>
        geo_out_cookie(sp, geo);
<% end -%>
    }
}C

// Emits a Set-Cookie
sub geoip_cookie {
<% if @varnish_version4 -%>
    C{geo_xcip_output(ctx);}C
<% else -%>
    C{geo_xcip_output(sp);}C
<% end -%>
}
