<% if @varnish_version4 -%>
vcl 4.0;
<% end -%>

// common backend code for all clusters
include "<%= @varnish_include_path %>wikimedia-common_<%= @vcl %>.inc.vcl";

/* Include the VCL file for this role */
include "<%= @varnish_include_path %><%= @vcl %>.inc.vcl";

sub vcl_init {
	call wm_common_directors_init;
}

// uses $req_handling to set backend and do backend maint
sub req_handle_backend_ {
<%
    def set_director(dirname)
        if @varnish_version4
            dir = @app_directors[dirname]
            if dir['type'] == 'hash'
                action = "set req.backend_hint = #{dirname}.backend(req.http.X-Client-IP);\n"
            else
                action = "set req.backend_hint = #{dirname}.backend();\n"
            end
        else
            action = "set req.backend = #{dirname};\n"
        end
        return action
    end

    def_action = error_synth(404, 'Domain not served here')
    if_stmts = []
    @vcl_config['req_handling'].keys.sort.each do |reqhost|
        options = @vcl_config[reqhost]
        if options.has_key?('subpaths')
            path_def_action = error_synth(404, 'Not Found')
            path_ifs = []
            options['subpaths'].keys.sort.each do |subpath|
                path_action = set_director(options['subpaths'][subpath]['director'])
                if subpath == 'default'
                    path_def_action = path_action
                else
                    path_ifs.push(%Q[if (req.url ~ "#{subpath}") { #{path_action} }]
                end
            end
            path_ifs.push("e { #{path_def_action} } ")
            host_action = path_ifs.join(' els')
        else
            host_action = set_director(options['director'])
        end

        if reqhost == 'default'
            def_action = host_action
        else
            if reqhost =~ /^[-.A-Za-z0-9]+$/
                hostop = '=='
            else
                hostop = '~'
            end
            hostcmp = %Q[req.http.Host #{hostop} "#{reqhost}"]
            if_stmts.push("if (#{hostcmp}) {\n        #{host_action}    }")
        end
    end
    if_stmts.push("e {\n        #{def_action}\n    }")
    set_backend = if_stmts.join(' els')
%>
    <%= set_backend -%>

<%
    maint_stmts = []
    @app_directors.keys.sort.each do |dirname|
        dir = @app_directors[dirname]
        if dir.key?('maintenance')
            action = error_synth(503, dir['maintenance'])
            if @varnish_version4
                # is this really correct in V4?
                maint_stmts.push(%Q[if (req.backend_hint == "#{dirname}") {\n        #{action}    }])
            else
                maint_stmts.push(%Q[if (req.backend == "#{dirname}") {\n        #{action}    }])
            end
        end
    end
    all_maint = maint_stmts.join(' els')
%>
    <%= all_maint -%>
}

sub vcl_recv {
	if (client.ip !~ wikimedia_trust) {
		// Do not allow direct access to non-frontend layers
		<%= error_synth(403, "Access denied") -%>
	}

<% if not @varnish_version4 -%>
	if (req.restarts == 0) {
		call wm_common_recv_set_xff;
	}
<% end -%>
	call wm_common_recv_early;

	// Backend loop detection: if a mistake is made in the code or config
	// for inter-cache routing, a request could loop infinitely between
	// backend caches without some sort of protection like
	// this.  The header may be re-used later for sideways
	// Only-If-Cached support as well.
	if (req.restarts == 0) {
		if (req.http.X-DCPath) {
			if (req.http.X-DCPath ~ "<%= @site %>") {
				<%= error_synth(508, "Loop Detected") -%>
			}
			set req.http.X-DCPath = req.http.X-DCPath + ", <%= site %>";
		} else {
			set req.http.X-DCPath = "<%= site %>";
		}
	}

<% if @cache_route == 'direct' -%>
	// tier-one caches must select an applayer backend
        call req_handle_backend_;
        call wm_common_recv_pass;
	call cluster_be_recv_applayer_backend;
<% else -%>
	<% if @varnish_version4 -%>
	set req.backend_hint = cache_<%= @cache_route %>.backend();
	<% else -%>
	set req.backend = cache_<%= @cache_route %>;
	<% end -%>
<% end -%>

	call wm_common_recv_grace;

<% if @varnish_version4 and @websocket_support -%>
	call wm_common_websocket_recv;
<% end -%>

	call cluster_be_recv_pre_purge;
	call wm_common_recv_purge;
	call cluster_be_recv;

	return (<%= @hash_lookup %>); // no default VCL
}

sub vcl_hash {
	call cluster_be_hash;
	// default vcl_hash invokes here!
}

<% if @varnish_version4 -%>
// http://book.varnish-software.com/4.0/chapters/Cache_Invalidation.html
sub vcl_purge {
	return (synth(204, "Purged"));
}
<% end -%>

sub vcl_hit {
	call wm_common_hit;
	call cluster_be_hit;
	return (deliver); // no default VCL (which is just "return (deliver)" anyways)
}

sub vcl_miss {
	call wm_common_miss;
	call cluster_be_miss;
	return (fetch); // no default VCL (which is just "return (fetch)" anyways)
}

sub vcl_pass {
	call wm_common_pass;

<% if @vcl_config.fetch("pass_random", false) -%>
<% if @cache_route != 'direct' -%>
	// pass-traffic should not use consistent hashing, to avoid unecessary
	// traffic focus on one node and keep things performant, *if* we're
	// fairly sure that all layers/tiers make equivalent pass decisions...
	<% if @varnish_version4 -%>
	set req.backend_hint = cache_<%= @cache_route %>_random.backend();
	<% else -%>
	set req.backend = cache_<%= @cache_route %>_random;
	<% end -%>
<% end -%>
<% end -%>

	call cluster_be_pass;
	return (<%= @fetch_pass %>); // no default VCL (which is just "return (<%= @fetch_pass %>)" anyways)
}

<% if @varnish_version4 and @websocket_support -%>
sub vcl_pipe {
	call wm_common_websocket_pipe;
}
<% end -%>

<% if @varnish_version4 -%>
sub vcl_backend_fetch {
    call cluster_be_backend_fetch;
}
<% end -%>

<% if @varnish_version4 -%>
sub vcl_backend_response {
<% else -%>
sub vcl_fetch {
<% end -%>
	call wm_common_backend_response;
	call cluster_be_backend_response;
	// default vcl_(fetch|backend_response) invokes here, unless cluster VCL unconditionally returns!
}

sub vcl_deliver {
	call wm_common_deliver_hitcount;
	call wm_common_xcache_deliver;
	call cluster_be_deliver;
	return (deliver); // no default VCL (which is just "return (deliver)" anyways)
}

<% if @varnish_version4 -%>

// Varnish4 vcl_synth+vcl_backend_error

sub vcl_synth {
	call wm_common_xcache_deliver;
	if (resp.status > 400 && resp.status != 413) {
		call synth_errorpage;
	}
	return (deliver);
}

sub vcl_backend_error {
	if (beresp.status > 400 && beresp.status != 413) {
		call backend_error_errorpage;
	}
	return (deliver);
}

<% else -%>

// Varnish3 vcl_error
sub vcl_error {
	call wm_common_v3_purge_error;
	if (obj.status > 400 && obj.status != 413) {
		call synth_errorpage;
	}
	return (deliver);
}

<% end -%>
