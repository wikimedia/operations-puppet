#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
  ssh-agent-proxy -- filtering proxy for ssh-agent

  Creates a UNIX domain socket that proxies connections to an ssh-agent(1)
  socket, disallowing any operations except listing identities and signing
  requests. Request signing is only permitted if group is allowed to use
  the requested public key fingerprint.

  Requirements: PyYAML (http://pyyaml.org/)

  usage: ssh-agent-proxy [--bind ADDRESS] [--connect ADDRESS] [--auth-dir DIR]

  Options:
    --bind ADDRESS    Bind the proxy to the UNIX domain socket at this address
                      (default: '/run/keyholder/proxy.sock').

    --connect ADDRESS Proxy connects to the ssh-agent socket at this address
                      (default: '/run/keyholder/agent.sock').

    --auth-dir DIR    Directory where YAML files containing group:[key(s)]
                      access can be found (default: '/etc/keyholder-auth.d').


  Copyright 2015 Ori Livneh <ori@wikimedia.org>
  Copyright 2015 Tyler Cipriani <thcipriani@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY CODE, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
import argparse
import glob
import grp
import hashlib
import os
import pwd
import select
import socket
import socketserver
import struct
import sys
import syslog

try:
    import yaml
except ImportError:
    sys.exit(
        'Error: ssh-agent-proxy requires PyYAML (http://pyyaml.org/)\n'
        'Debian / Ubuntu: `apt-get install python3-yaml`\n'
        'RHEL / Fedora / CentOS: `yum install python-yaml`\n'
        'All others: `pip3 install PyYAML`'
    )


# Defined in <socket.h>.
SO_PEERCRED = 17

# These constants are part of OpenSSH's ssh-agent protocol spec.
# See <http://api.libssh.org/rfc/PROTOCOL.agent>.
SSH2_AGENTC_REQUEST_IDENTITIES = 11
SSH2_AGENTC_SIGN_REQUEST = 13
SSH_AGENTC_REQUEST_RSA_IDENTITIES = 1
SSH_AGENT_FAILURE = 5

s_message_header = struct.Struct('!LB')
s_ucred = struct.Struct('2Ii')


def unpack_variable_length_string(buffer, offset=0):
    """Read a variable-length string from a buffer. The first 4 bytes are the
    big-endian unsigned long representing the length of the string."""
    size = struct.unpack_from('!L', buffer, offset)
    string, = struct.unpack_from('xxxx%ds' % size, buffer, offset)
    return string


def get_key_permissions(path):
    """Recursively walk `path`, loading YAML configuration files."""
    key_permissions = {}
    for fname in glob.glob(os.path.join(path, '*.y*ml')):
        with open(fname) as yml:
            for group, keys in yaml.safe_load(yml).items():
                for key in keys:
                    key = key.replace(':', '')
                    key_permissions.setdefault(key, set()).add(group)
    return key_permissions


class SshAgentProxyServer(socketserver.ThreadingUnixStreamServer):
    """A threaded server that listens on a UNIX domain socket and handles
    requests by filtering them and proxying them to a backend SSH agent."""

    def __init__(self, server_address, agent_address, key_permissions):
        super().__init__(server_address, SshAgentProxyHandler)
        self.agent_address = agent_address
        self.key_permissions = key_permissions


class SshAgentProxyHandler(socketserver.BaseRequestHandler):
    """This class is responsible for handling an individual connection
    to an SshAgentProxyServer."""

    def get_peer_credentials(self, sock):
        """Return the user and group name of the peer of a UNIX socket."""
        ucred = sock.getsockopt(socket.SOL_SOCKET, SO_PEERCRED, s_ucred.size)
        _, uid, gid = s_ucred.unpack(ucred)
        user = pwd.getpwuid(uid).pw_name
        groups = {grp.getgrgid(gid).gr_name}
        groups.update(g.gr_name for g in grp.getgrall() if user in g.gr_mem)
        return user, groups

    def setup(self):
        """Set up a connection to the backend SSH agent backend."""
        self.backend = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.backend.setblocking(False)
        self.backend.connect(self.server.agent_address)

    def recv_message(self, sock):
        """Read a message from a socket."""
        header = sock.recv(s_message_header.size, socket.MSG_WAITALL)
        try:
            size, code = s_message_header.unpack(header)
        except struct.error:
            return None, b''
        message = sock.recv(size - 1, socket.MSG_WAITALL)
        return code, message

    def send_message(self, sock, code, message=b''):
        """Send a message on a socket."""
        header = s_message_header.pack(len(message) + 1, code)
        sock.sendall(header + message)

    def handle_backend(self):
        """Read data from the backend SSH agent and send to client."""
        code, message = self.recv_message(self.backend)
        self.send_message(self.request, code, message)

    def handle_client_request(self):
        """Read data from client and send to backend SSH agent."""
        code, message = self.recv_message(self.request)

        if code == SSH2_AGENTC_REQUEST_IDENTITIES:
            return self.send_message(self.backend, code, message)

        if code == SSH_AGENTC_REQUEST_RSA_IDENTITIES:
            return self.send_message(self.backend, code, message)

        if code == SSH2_AGENTC_SIGN_REQUEST:
            key = unpack_variable_length_string(message)
            digest = hashlib.md5(key).hexdigest()
            user, groups = self.get_peer_credentials(self.request)
            if groups & self.server.key_permissions.get(digest, set()):
                syslog.syslog(syslog.LOG_INFO, 'Allowing signing request '
                              'from user %s using key %s.' % (user, digest))
                return self.send_message(self.backend, code, message)
            syslog.syslog(syslog.LOG_NOTICE, 'Denying signing request '
                          'from user %s using key %s.' % (user, digest))

        return self.send_message(self.request, SSH_AGENT_FAILURE)

    def handle(self):
        """Handle a new client connection by shuttling data between the client
        and the backend."""
        syslog.syslog('New connection from %s.' % self.client_address)
        while 1:
            rlist, *_ = select.select((self.backend, self.request), (), (), 1)
            if self.backend in rlist:
                self.handle_backend()
            if self.request in rlist:
                self.handle_client_request()


ap = argparse.ArgumentParser(description='filtering proxy for ssh-agent')
ap.add_argument(
    '--bind',
    default='/run/keyholder/proxy.sock',
    help='Bind the proxy to the domain socket at this address'
)
ap.add_argument(
    '--connect',
    default='/run/keyholder/agent.sock',
    help='Proxy connects to the ssh-agent socket at this address'
)
ap.add_argument(
    '--auth-dir',
    default='/etc/keyholder-auth.d',
    help='directory with YAML configuration files'
)
args = ap.parse_args()

key_perms = get_key_permissions(args.auth_dir)
syslog.openlog(logoption=syslog.LOG_PID, facility=syslog.LOG_AUTH)
SshAgentProxyServer(args.bind, args.connect, key_perms).serve_forever()
