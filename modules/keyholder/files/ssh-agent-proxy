#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
  ssh-agent-proxy -- filtering proxy for ssh-agent

  Creates a UNIX domain socket that proxies connections to an ssh-agent(1)
  socket, disallowing any operations except listing identities and signing
  requests. Request signing is only permitted if group is allowed to use
  the requested public key fingerprint.

  Requirements: PyYAML (http://pyyaml.org/)

  usage: ssh-agent-proxy [--bind ADDRESS] [--connect ADDRESS] [--auth-dir DIR]

  Options:
    --bind ADDRESS    Bind the proxy to the UNIX domain socket at this address
                      (default: '/run/keyholder/proxy.sock').

    --connect ADDRESS Proxy connects to the ssh-agent socket at this address
                      (default: '/run/keyholder/agent.sock').

    --auth-dir DIR    Directory where YAML files containing group:[key(s)]
                      access can be found (default: '/etc/keyholder-auth.d').


  Copyright 2015 Ori Livneh <ori@wikimedia.org>
  Copyright 2015 Tyler Cipriani <thcipriani@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY CODE, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
import argparse
import errno
import grp
import hashlib
import os
import pwd
import select
import socket
import socketserver
import struct
import sys
import syslog

try:
    import yaml
except ImportError:
    sys.exit(
        'Error: ssh-agent-proxy requires PyYAML (http://pyyaml.org/)\n'
        'Debian / Ubuntu: `apt-get install python3-yaml`\n'
        'RHEL / Fedora / CentOS: `yum install python-yaml`\n'
        'All others: `pip3 install PyYAML`'
    )


SSH_AGENT_FAILURE = 5
SO_PEERCRED = 17

s_ns_header = struct.Struct('!L')
s_message_header = struct.Struct('!LB')
s_ucred = struct.Struct('2Ii')

syslog.openlog(logoption=syslog.LOG_PID, facility=syslog.LOG_AUTH)


class SshAgentProxyServer(socketserver.ThreadingUnixStreamServer):
    def __init__(self, server_address, agent_address, key_permissions):
        self.agent_address = agent_address
        super(SshAgentProxyServer, self).__init__(
                server_address, SshAgentProxyHandler)
        self.key_permissions = key_permissions


class SshAgentProxyHandler(socketserver.BaseRequestHandler):
    # See <http://api.libssh.org/rfc/PROTOCOL.agent>
    permitted_requests = {
        0x1: 'SSH_AGENTC_REQUEST_RSA_IDENTITIES',
        0xb: 'SSH2_AGENTC_REQUEST_IDENTITIES',
        0xd: 'SSH2_AGENTC_SIGN_REQUEST',
    }

    def get_peer_credentials(self, sock):
        credentials = sock.getsockopt(
            socket.SOL_SOCKET, SO_PEERCRED, s_ucred.size)
        pid, uid, gid = s_ucred.unpack(credentials)
        user_name = pwd.getpwuid(uid).pw_name
        groups = {g.gr_name for g in grp.getgrall() if user_name in g.gr_mem}
        groups.add(grp.getgrgid(gid).gr_name)
        return user_name, groups

    def setup(self):
        self.proxy = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.proxy.setblocking(False)
        self.proxy.connect(self.server.agent_address)
        self.sockets = (self.request, self.proxy)

    def recv_message(self, sock):
        header = sock.recv(s_message_header.size, socket.MSG_WAITALL)
        if len(header) < s_message_header.size:
            return None, b''
        size, code = s_message_header.unpack(header)
        message = sock.recv(size - 1, socket.MSG_WAITALL)
        return code, message

    def send_message(self, sock, code, message=b''):
        header = s_message_header.pack(len(message) + 1, code)
        sock.sendall(header + message)

    def get_fingerprint_from_ns(self, msg):
        """Get key from netstring sign request

        retrieves key from SSH2_AGENTC_SIGN_REQUEST (first 4 bytes are
        the big-endian unsigned long representing length of the key,
        remaining bytes are signing message). Returns md5 base64 key
        representation and compares result against key_permissions hash.
        """
        key_start = s_ns_header.size
        key_length, = s_ns_header.unpack_from(msg)
        key_blob = msg[key_start:key_start + key_length]
        return hashlib.md5(key_blob).hexdigest()

    def check_key(self, groups, msg):
        """Checks key fingerprint and group membership against key_permissions
        """
        fingerprint = self.get_fingerprint_from_ns(msg)
        for group in groups:
            if fingerprint in self.server.key_permissions.get(group, ()):
                return True
        return False

    def authorized_request(self, code, groups, message):
        """Checks if the code of the request is a permitted request type. If
        the request type is permitted and the request type is a sign request
        check group/key permissions.
        """
        if code not in self.permitted_requests:
            return False

        if self.permitted_requests[code] == 'SSH2_AGENTC_SIGN_REQUEST':
            return self.check_key(groups, message)

        return True

    def handle(self):
        while 1:
            readable, *_ = select.select(self.sockets, (), (), 1)
            if self.proxy in readable:
                code, message = self.recv_message(self.proxy)
                self.send_message(self.request, code, message)
            if self.request in readable:
                code, message = self.recv_message(self.request)
                if code is None:
                    return
                user, groups = self.get_peer_credentials(self.request)
                req = self.permitted_requests.get(code, 'UNKNOWN (%s)' % code)
                syslog.syslog('Received %s from %s:%s' % (req, user, groups))

                if self.authorized_request(code, groups, message):
                    self.send_message(self.proxy, code, message)
                else:
                    self.send_message(self.request, SSH_AGENT_FAILURE)


def raise_err(err):
    raise err


def get_permissions(path):
    """Recursively walk `path`, loading YAML configuration files."""
    permissions = {}
    for _, _, files in os.walk(path, onerror=raise_err):
        for f in files:
            with open(os.path.join(path, f)) as yml:
                for group, keys in yaml.load(yml).items():
                    sanitized_keys = (key.replace(':', '') for key in keys)
                    permissions.setdefault(group, []).extend(sanitized_keys)
    return permissions


ap = argparse.ArgumentParser(description='Filtering proxy for ssh-agent(1)')
ap.add_argument('--bind', default='/run/keyholder/proxy.sock',
                help='Bind the proxy to the domain socket at this address')
ap.add_argument('--connect', default='/run/keyholder/agent.sock',
                help='Proxy connects to the ssh-agent socket at this address')
ap.add_argument('--auth-dir', default='/etc/keyholder-auth.d',
                help='directory with YAML files containing group names'
                     'mapped to arrays of SSH public key fingerprints')
args = ap.parse_args()

syslog.syslog('Proxying %s -> %s' % (args.bind, args.connect))
proxy = SshAgentProxyServer(args.bind, args.connect,
                            get_permissions(args.auth_dir))
proxy.serve_forever()
