#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
  ssh-agent-proxy -- filtering proxy for ssh-agent

  Creates a UNIX domain socket that proxies connections to an ssh-agent(1)
  socket, disallowing any operations except listing identities and signing
  requests. Request signing is only permitted if group is allowed to use
  the requested public key fingerprint.

  Requirements: PyYAML

  usage: ssh-agent-proxy [--bind ADDRESS] [--connect ADDRESS] [--auth-dir DIR]

  Options:
    --bind ADDRESS    Bind the proxy to the UNIX domain socket at this address
    --connect ADDRESS Proxy connects to the ssh-agent socket at this address
    --auth-dir DIR    Directory where yaml files containing group:[key(s)]
                      access can be found


  Copyright 2014 Ori Livneh <ori@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY CODE, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
import argparse
import errno
import grp
import hashlib
import os
import pwd
import select
import socket
import socketserver
import struct
import syslog

import yaml

SSH_AGENT_FAILURE = 5
SO_PEERCRED = 17

ns_header = struct.Struct('!L')
s_message_header = struct.Struct('!LB')
s_ucred = struct.Struct('2Ii')

syslog.openlog(logoption=syslog.LOG_PID, facility=syslog.LOG_AUTH)


class SshAgentProxyHandler(socketserver.BaseRequestHandler):
    # See <http://api.libssh.org/rfc/PROTOCOL.agent>
    permitted_requests = {
        0x1: 'SSH_AGENTC_REQUEST_RSA_IDENTITIES',
        0xb: 'SSH2_AGENTC_REQUEST_IDENTITIES',
        0xd: 'SSH2_AGENTC_SIGN_REQUEST',
    }

    def get_peer_credentials(self, sock):
        credentials = sock.getsockopt(
            socket.SOL_SOCKET, SO_PEERCRED, s_ucred.size)
        pid, uid, gid = s_ucred.unpack(credentials)
        user_name = pwd.getpwuid(uid).pw_name
        groups = {g.gr_name for g in grp.getgrall() if user_name in g.gr_mem}
        groups.add(grp.getgrgid(gid).gr_name)
        return user_name, groups

    def setup(self):
        self.proxy = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.proxy.setblocking(False)
        self.proxy.connect(self.connect)
        self.sockets = (self.request, self.proxy)

    def recv_message(self, sock):
        header = sock.recv(s_message_header.size, socket.MSG_WAITALL)
        if len(header) < s_message_header.size:
            return None, b''
        size, code = s_message_header.unpack(header)
        message = sock.recv(size - 1, socket.MSG_WAITALL)
        return code, message

    def send_message(self, sock, code, message=b''):
        header = s_message_header.pack(len(message) + 1, code)
        sock.sendall(header + message)

    def get_fingerprint_from_ns(self, msg):
        """Get key from netstring sign request

        retrieves key from SSH2_AGENTC_SIGN_REQUEST (first 4 bytes are
        the big-endian unsigned long representing length of the key,
        remaining bytes are signing message). Returns md5 base64 key
        representation and compares result against key_permissions hash.
        """
        bl = ns_header.size
        l, = ns_header.unpack_from(msg)

        key_blob = msg[bl:bl + l]

        finger = hashlib.md5(key_blob).hexdigest()

        return ':'.join(a + b for a, b in zip(finger[::2], finger[1::2]))

    def check_key(self, groups, msg):
        """Checks key fingerprint and group membership against key_permissions
        """
        fprint = self.get_fingerprint_from_ns(msg)
        for group in groups:
            if fprint in self.key_permissions.get(group, ()):
                return True
        return False

    def authorized_request(self, code, groups, message):
        """Checks if the code of the request is a permitted request type. If
        the request type is permitted and the request type is a sign request
        check group/key permissions.
        """
        if code not in self.permitted_requests:
            return False

        if self.permitted_requests[code] == 'SSH2_AGENTC_SIGN_REQUEST':
            return self.check_key(groups, message)

        return True

    def handle(self):
        while 1:
            readable, *_ = select.select(self.sockets, (), (), 1)
            if self.proxy in readable:
                code, message = self.recv_message(self.proxy)
                self.send_message(self.request, code, message)
            if self.request in readable:
                code, message = self.recv_message(self.request)
                if code is None:
                    return
                user, groups = self.get_peer_credentials(self.request)
                req = self.permitted_requests.get(code, 'UNKNOWN (%s)' % code)
                syslog.syslog('Received %s from %s:%s' % (req, user, groups))

                if self.authorized_request(code, groups, message):
                    self.send_message(self.proxy, code, message)
                else:
                    self.send_message(self.request, SSH_AGENT_FAILURE)


def get_permissions(path):
    if not os.path.isdir(path):
        raise FileNotFoundError(errno.ENOENT, 'Directory not found', path)

    permissions = {}
    for _, _, files in os.walk(path):
        for f in files:
            with open(os.path.join(path, f)) as yml:
                permissions.update(yaml.load(yml))

    return permissions


ap = argparse.ArgumentParser(description='Filtering proxy for ssh-agent(1)')
ap.add_argument('--bind', default='/run/keyholder/proxy.sock',
                help='Bind the proxy to the domain socket at this address')
ap.add_argument('--connect', default='/run/keyholder/agent.sock',
                help='Proxy connects to the ssh-agent socket at this address')
ap.add_argument('--auth-dir', default='/etc/keyholder-auth.d',
                help='directory with yaml files containing group names'
                     'mapped to arrays of ssh public key fingerprints')
args = ap.parse_args()

SshAgentProxyHandler.connect = args.connect
SshAgentProxyHandler.key_permissions = get_permissions(args.auth_dir)

syslog.syslog('Proxying %s -> %s' % (args.bind, args.connect))
proxy = socketserver.ThreadingUnixStreamServer(args.bind, SshAgentProxyHandler)
proxy.serve_forever()
