#!/usr/bin/env python
# -*- coding: utf-8 -*-

# acme-setup - basic pre-ACME key/cert setup
# Copyright 2016 Brandon Black
# Copyright 2016 Wikimedia Foundation, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# ----------------------------------------------------------------------------
# This script does all of the offline pre-setup steps (no network fetches or
# challenges) for an ACME-based TLS certificate.  The intent here is that
# puppetization can run through a sequence like this:
#
# 1. Write the webserver config (apache, nginx, etc) with TLS
#    enabled and final cert/key/chain paths from /etc/acme/<id>/
# 2. Execute this script, which will create the necessary files/directories if
#    they don't already exist (and will fix up perms otherwise).  If it has to
#    create the certificate from scratch, it will create a self-signed cert
#    based on the same privkey and CSR we'd use for ACME.
# 3. Start the webserver, which should load it's real configuration
#    successfully, even though TLS is browser-invalid due to self-signing.
# 4. Execute an ACME challenge script which may overwrite the certificate with
#    a better one after executing a challenge through the webserver above.  It
#    should only do this conditionally if it finds the existing cert is
#    self-signed, or the existing cert's expiry is near (<30d).  It only needs
#    to do the cert-generation step; the necessary private keys and CSR are
#    pre-made for it by this script.
#
# This script should be idempotent under normal working conditions - it can be
# executed before => Service['WebServerFoo'] on every puppet run and will
# usually just do a few stat checks and readonly openssl commands to validate
# that everything's sane.  The conditional ACME challenge script would always
# run afterwards, i.e. require => Service['WebServerFoo'].  This script won't
# overwrite the work of the ACME challenge script under normal conditions.
#
# This script *will* react to subject-list changes: if you change the subject
# list from the previous setup, it's going to wipe and re-create the CSR and
# self-signed cert, and the ACME challenge script will need to fix things up
# from there forward again when it notices the self-signed cert state.
#
# The --cert-user argument (default 'acme') will own the certificates (but not
# other files) so that this unprivileged user can be used to run the ACME
# script itself, which will probably have to talk to network sources.
#
# ----------------------------------------------------------------------------
# directory/file layout generated by this the code (with 'x' as the id):
# /etc/acme/                        - root:root/755
# /etc/acme/x/                      - root:root/755
# /etc/acme/x/csr.pem               - root:root/644
# /etc/acme/x/key/                  - root:root/700
# /etc/acme/x/key/acct.key          - root:root/400
# /etc/acme/x/key/tls.key           - root:root/400
# /etc/acme/x/cert/                 - cert_user:root/755
# /etc/acme/x/cert/tls.cert         - cert_user:root/644
# /etc/acme/x/cert/tls.chain.cert   - cert_user:root/644
# /etc/acme/x/cert/tls.chained.cert - cert_user:root/644
# ----------------------------------------------------------------------------


import re
import os
import sys
import pwd
import stat
import errno
import shutil
import argparse
import tempfile
import subprocess


def info(str):
    """Saves some code line noise"""
    sys.stderr.write(str + '\n')


def parse_options():
    """Parse command-line options, return args hash"""
    parser = argparse.ArgumentParser(description="WLE Setup")

    parser.add_argument('--user-for-cert', '-u', dest='cert_user',
                        help='user name for cert write',
                        type=str, default='acme')
    parser.add_argument('--id', '-i', dest='id',
                        help='unique identifier on this host',
                        type=str, required=True)
    parser.add_argument('--subjects', '-s', dest='subjects',
                        help='comma-separated list of Subjects',
                        required=True, type=lambda s: s.split(','))

    return parser.parse_args()


def check_output_errtext(args):
    """exec args, returns (stdout,stderr). raises on rv!=0 w/ stderr in msg"""

    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (p_out, p_err) = p.communicate()
    if p.returncode != 0:
        raise Exception("Command >>%s<< failed with exit code %i, stderr:\n%s"
                        % (" ".join(args), p.returncode, p_err))
    return (p_out, p_err)


def ensure_real_fs(path, mode, uid, gid, is_dir, creator, forcer):
    """Ensure real file/dir with above params, rv indicates creation"""

    create = False
    try:
        st = os.lstat(path)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            create = True
        else:
            raise

    if create or forcer():
        creator()
        create = True
        st = os.lstat(path)
    if is_dir:
        if not stat.S_ISDIR(st.st_mode):
            raise Exception('%s is not a directory' % (path))
    else:
        if not stat.S_ISREG(st.st_mode):
            raise Exception('%s is not a regular file' % (path))
    if st.st_uid != uid or st.st_gid != gid:
        os.chown(path, uid, gid)
    if (st.st_mode & 0o777) != mode:
        os.chmod(path, mode)

    return create


def ensure_dir(dir, uid, gid, mode):
    """Ensure dir exists with this uid/gid/mode"""

    def dir_create():
        info('Creating directory ' + dir)
        os.mkdir(dir, mode)

    def dir_force():
        return False

    ensure_real_fs(dir, mode, uid, gid, True, dir_create, dir_force)


def ensure_key(file, mode, bits):
    """Ensure root-owned key w/ correct mode, use bits if creating"""

    def key_create():
        info('Creating Key ' + file)
        check_output_errtext(['openssl', 'genrsa', '-out', file, str(bits)])

    def key_force():
        return False

    return ensure_real_fs(file, mode, 0, 0, False, key_create, key_force)


def subjects_eq(file, subjects, which):
    """Check Cert or CSR is for subjects"""

    csr_txt = check_output_errtext(['openssl', which, '-in', file, '-text'])[0]
    if not re.search('^\s*Subject: CN=' + re.escape(subjects[0]) + '$',
                     csr_txt, re.M):
        return False
    if len(subjects) > 1:
        san_str = ',\s*'.join(['DNS:' + re.escape(s) for s in subjects])
        if not re.search('\s+X509v3 Subject Alternative Name:\s+' +
                         san_str + '\n', csr_txt, re.M):
            return False
    return True


def make_csr_cfg(subjects):
    """Create tempfile w/ CSR cfg, return name"""

    if len(subjects) > 1:
        san = (
            'subjectAltName=' +
            ','.join(['DNS:' + s for s in subjects]) + '\n'
        )
    else:
        san = ''

    cfg = (
        '[req]\n'
        'distinguished_name=req_dn\n'
        'req_extensions=v3_req\n'
        '[req_dn]\n'
        'commonName=' + subects[0] + '\n'
        '[v3_req]\n'
        'keyUsage=critical,digitalSignature,keyEncipherment\n'
        'basicConstraints=CA:FALSE\n'
        'extendedKeyUsage=serverAuth\n'
    ) + san

    cfgfile = tempfile.NamedTemporaryFile(delete=False)
    cfgfile.write(cfg)
    return cfgfile.name


def ensure_csr(file, mode, subjects, tls_key, force):
    """Ensure CSR for subjects"""

    def csr_create():
        info('Creating CSR ' + file)
        cfg_temp = make_csr_cfg(subjects)
        check_output_errtext([
            'openssl', 'req', '-new', '-sha256',
            '-out', file, '-key', tls_key, '-subj',
            '/CN=' + subjects[0], '-config', cfg_temp
        ])
        os.unlink(cfg_temp)

    def csr_force():
        return force or not subjects_eq(file, subjects, 'req')

    return ensure_real_fs(file, mode, 0, 0, False, csr_create, csr_force)


def ensure_cert(file, mode, cert_uid, tls_key, csr, subjects, force):
    """Ensure valid cert exists (self-signed if must create)"""

    def cert_create():
        info('Creating self-signed cert ' + file)
        cfg_temp = make_csr_cfg(subjects)
        check_output_errtext([
            'openssl', 'x509', '-req', '-sha256', '-sha256',
            '-out', file, '-in', csr, '-signkey', tls_key,
            '-extfile', cfg_temp, '-extensions', 'v3_req'
        ])
        os.unlink(cfg_temp)

    def cert_force():
        return force or not subjects_eq(file, subjects, 'x509')

    return ensure_real_fs(file, mode, cert_uid, 0, False,
                          cert_create, cert_force)


def acme_setup(id, cert_user, subjects):
    """Set up all the things in /etc/acme/<id>/"""

    cert_uid = pwd.getpwnam(cert_user).pw_uid

    # Directory structure
    base_dir = '/etc/acme'
    this_dir = base_dir + '/' + id
    key_dir = this_dir + '/key'
    cert_dir = this_dir + '/cert'
    ensure_dir(base_dir, 0, 0, 0o755)
    ensure_dir(this_dir, 0, 0, 0o755)
    ensure_dir(key_dir, 0, 0, 0o700)
    ensure_dir(cert_dir, cert_uid, 0, 0o755)

    # Keys
    acct_key = key_dir + '/acct.key'
    ensure_key(acct_key, 0o400, 4096)
    tls_key = key_dir + '/tls.key'
    force_csr = ensure_key(tls_key, 0o400, 2048)

    # CSR based on tls_key + subjects
    csr = this_dir + '/csr.pem'
    force_cert = ensure_csr(csr, 0o644, subjects, tls_key, force_csr)

    # Cert based on CSR + subjects (self-signed if need to generate)
    tls_cert = cert_dir + '/tls.crt'
    make_chains = ensure_cert(tls_cert, 0o644, cert_uid, tls_key, csr,
                              subjects, force_cert)

    # For now, chain/chained are copies of tls.crt if we created tls.crt.
    # If we created tls.cert self-signed above there's no true chain, but
    # hopefully this lets any server config start up correctly.
    if make_chains:
        c_chain = cert_dir + '/tls.chain.crt'
        c_chained = cert_dir + '/tls.chained.crt'
        for fn in [c_chain, c_chained]:
            info('Copying ' + tls_cert + ' to ' + fn)
            shutil.copy(tls_cert, fn)
            os.chown(fn, cert_uid, 0)


def main():
    os.umask(022)
    args = parse_options()
    # The rest of the script assumes running as euid/egid==0
    if os.geteuid() != 0 or os.getegid() != 0:
        raise Exception('This script must run as root')
    acme_setup(args.id, args.cert_user, args.subjects)


if __name__ == '__main__':
    main()

# vim: set ts=4 sw=4 et:
