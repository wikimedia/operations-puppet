#!/usr/bin/env python
# -*- coding: utf-8 -*-

# acme-setup - ACME setup and challenge-wrapper script
# Copyright 2016 Brandon Black
# Copyright 2016 Wikimedia Foundation, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# ----------------------------------------------------------------------------
# Regardless of challenge-mode, this script always sets up the basic
# directories and files for /etc/acme/<id>/{keys,certs} and such, and ensures
# private keys and the CSR exist with correct permissions and subjects,
# (re-)creating them if necessary.
#
# If the challenge-mode is set to 'none' (the default), the output certificate
# files will be self-signed; no actual ACME challenges are executed and no
# network fetches happen at all.  The intent of this mode is that it is used to
# pre-setup the configuration of a server for an 'integrated' challenge
# (allowing the server to start in its normal configuration with TLS keys
# loaded successfully, etc).
#
# When executed with challenge-mode 'integrated', the script assumes:
# 1) the web_service argument is a running service daemon listening on port 80,
#    which has been configured to map /.well-known/acme-challenge to the
#    challenge_dir argument.  It should be ok if port 80 redirects everything
#    to HTTPS and HTTPS serves the challenge directory as well using the
#    self-signed cert generated by the 'none' mode (XXX needs verification!)
# 2) that 'service $web_service reload' is sufficient to make the service aware
#    of updated TLS certificates.  Using these assumptions, if it finds there
#    is not a valid certificate already in place (where valid includes: matches
#    the correct subject list, not self-signed, expiry >now+30d), it executes
#    an ACME network challenge (running the challenge script itself as the
#    acme_user argument) and reloads the service afterwards to use the new key.
#
# When executed with challenge-mode 'standalone', operation is similar to
# integrated, but it is assumed web_service can't be configured to map
# /.well-known/acme-challenge to the challenge_dir.  If the cert needs
# (re-)generation:
# 1) the web_service is stopped with 'service $web_service stop'
# 2) a temporary mini-service to answer challenges on port 80 starts
# 3) the ACME challenge is executed, outputting the new cert
# 4) the mini-service is stopped
# 5) the web_service is started via 'service $web_service start'
# ----------------------------------------------------------------------------
#
# The intended integration with puppet (or similar) is:
#
# integrated:
# * configure webserver (nginx/apache/whatever) to include a standard config
#   fragment to map /.well-known/acme-challenge to $challenge_dir
# * configure webserver for TLS with the key/cert args set to the output
#   locations of this script
# * execute this script with challenge_mode 'none' to generate everything with
#   merely a self-signed cert, before => Service[$web_server].
# * execute this script again with challenge_mode 'integrated', with requires
#   => Service[$web_server].
# * for renewal, have a daily cron re-run this with challenge_mode
#   'integrated', or if puppet runs regularly throughout the day, the above
#   should take care of this on its own.
#
# standalone - as above but:
# * No config for $challenge_dir mapping (e.g. some custom java server app)
# * Do not run with challenge_mode 'none' ever, just run with 'standalone'
#   before => Service[$web_server].
# * Expect a short downtime every ~60d when the service is briefly stopped for
#   standalone challenge execution for renewals (again, this could happen from
#   your exec on every puppet run, or a daily cron of 'standalone' mode)
#
# ----------------------------------------------------------------------------
# directory/file layout generated by this the code (with 'x' as the id):
# /etc/acme/                       - root:root/755
# /etc/acme/x/                     - root:root/755
# /etc/acme/x/csr.pem              - root:root/644
# /etc/acme/x/key/                 - root:root/711
# /etc/acme/x/key/tls.key          - root:root/400
# /etc/acme/x/key/acct.key         - acme_user:root/400
# /etc/acme/x/cert/                - root:root/755
# /etc/acme/x/cert/tls.crt         - root:root/644
# /etc/acme/x/cert/tls.chain.crt   - root:root/644
# /etc/acme/x/cert/tls.chained.crt - root:root/644
# ----------------------------------------------------------------------------
# Note that while this script is named as if it's generic to any usage of ACME,
# at present it's full of LetsEncrypt assumptions (that account keys are
# mostly-ephemeral, the challenge server addresses, how CSRs are constructed,
# etc), because that's all we're using here.  The intent is to refactor/expand
# this script at a later date when we have a second use-case for e.g. ACME with
# a commercial cert vendor.
# ----------------------------------------------------------------------------


import re
import os
import sys
import pwd
import stat
import errno
import shutil
import argparse
import tempfile
import subprocess


def info(str):
    """Saves some code line noise"""
    sys.stderr.write(str + '\n')


def parse_options():
    """Parse command-line options, return args hash"""
    parser = argparse.ArgumentParser(description="WLE Setup")

    parser.add_argument('--user-for-acme', '-u', dest='acme_user',
                        help='unprivileged acme user name',
                        type=str, default='acme')
    parser.add_argument('--challenge-dir', '-d', dest='challenge_dir',
                        help='challenge dir',
                        type=str, default='/var/www/acme-challenge')
    parser.add_argument('--id', '-i', dest='id',
                        help='unique identifier on this host',
                        type=str, required=True)
    parser.add_argument('--subjects', '-s', dest='subjects',
                        help='comma-separated list of Subjects',
                        required=True, type=lambda s: s.split(','))
    # XXX below: integrated, standalone, none
    parser.add_argument('--challenge-mode', '-c', dest='challenge_mode',
                        help='challenge mode',
                        type=str, default='none')
    # XXX: if challenge mode != 'none', we need a sevice name, otherwise empty is ok
    parser.add_argument('--web-service', '-w', dest='web_service',
                        help='web service name',
                        type=str, default='none')

    return parser.parse_args()


def check_output_errtext(args):
    """exec args, returns (stdout,stderr). raises on rv!=0 w/ stderr in msg"""

    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (p_out, p_err) = p.communicate()
    if p.returncode != 0:
        raise Exception("Command >>%s<< failed with exit code %i, stderr:\n%s"
                        % (" ".join(args), p.returncode, p_err))
    return (p_out, p_err)


def ensure_real_fs(path, mode, uid, gid, is_dir, creator, forcer):
    """Ensure real file/dir with above params, rv indicates creation"""

    create = False
    try:
        st = os.lstat(path)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            create = True
        else:
            raise

    if create or forcer():
        creator()
        create = True
        st = os.lstat(path)
    if is_dir:
        if not stat.S_ISDIR(st.st_mode):
            raise Exception('%s is not a directory' % (path))
    else:
        if not stat.S_ISREG(st.st_mode):
            raise Exception('%s is not a regular file' % (path))
    if st.st_uid != uid or st.st_gid != gid:
        os.chown(path, uid, gid)
    if (st.st_mode & 0o777) != mode:
        os.chmod(path, mode)

    return create


def ensure_dir(dir, mode):
    """Ensure root-owned dir exists with this mode"""

    def dir_create():
        info('Creating directory ' + dir)
        os.mkdir(dir, mode)

    def dir_force():
        return False

    ensure_real_fs(dir, mode, 0, 0, True, dir_create, dir_force)


def ensure_key(file, uid, gid, mode, bits):
    """Ensure root-owned key w/ correct mode, use bits if creating"""

    def key_create():
        info('Creating Key ' + file)
        check_output_errtext(['openssl', 'genrsa', '-out', file, str(bits)])

    def key_force():
        return False

    return ensure_real_fs(file, mode, uid, gid, False, key_create, key_force)


def subjects_eq(file, subjects, which):
    """Check Cert or CSR is for subjects"""

    csr_txt = check_output_errtext(['openssl', which, '-in', file, '-text'])[0]
    if not re.search('^\s*Subject: CN=' + re.escape(subjects[0]) + '$',
                     csr_txt, re.M):
        return False
    if len(subjects) > 1:
        san_str = ',\s*'.join(['DNS:' + re.escape(s) for s in subjects])
        if not re.search('\s+X509v3 Subject Alternative Name:\s+' +
                         san_str + '\n', csr_txt, re.M):
            return False
    return True


def make_csr_cfg(subjects):
    """Create tempfile w/ CSR cfg, return name"""

    if len(subjects) > 1:
        san = (
            'subjectAltName=' +
            ','.join(['DNS:' + s for s in subjects]) + '\n'
        )
    else:
        san = ''

    cfg = (
        '[req]\n'
        'distinguished_name=req_dn\n'
        'req_extensions=v3_req\n'
        '[req_dn]\n'
        'commonName=' + subects[0] + '\n'
        '[v3_req]\n'
        'keyUsage=critical,digitalSignature,keyEncipherment\n'
        'basicConstraints=CA:FALSE\n'
        'extendedKeyUsage=serverAuth\n'
    ) + san

    cfgfile = tempfile.NamedTemporaryFile(delete=False)
    cfgfile.write(cfg)
    return cfgfile.name


def ensure_csr(file, subjects, tls_key, force):
    """Ensure CSR for subjects"""

    def csr_create():
        info('Creating CSR ' + file)
        cfg_temp = make_csr_cfg(subjects)
        check_output_errtext([
            'openssl', 'req', '-new', '-sha256',
            '-out', file, '-key', tls_key, '-subj',
            '/CN=' + subjects[0], '-config', cfg_temp
        ])
        os.unlink(cfg_temp)

    def csr_force():
        return force or not subjects_eq(file, subjects, 'req')

    return ensure_real_fs(file, 0o644, 0, 0, False, csr_create, csr_force)


def ensure_cert_self(cert_dir, tls_key, csr, subjects, force):
    """Ensure valid cert exists (self-signed if must create)"""

    tls_cert = cert_dir + '/tls.crt'
    def cert_create():
        info('Creating self-signed cert ' + tls_cert)
        cfg_temp = make_csr_cfg(subjects)
        check_output_errtext([
            'openssl', 'x509', '-req', '-sha256',
            '-out', tls_cert, '-in', csr, '-signkey', tls_key,
            '-extfile', cfg_temp, '-extensions', 'v3_req'
        ])
        os.unlink(cfg_temp)

    def cert_force():
        return force or not subjects_eq(tls_cert, subjects, 'x509')

    make_chains = ensure_real_fs(tls_cert, 0o644, 0, 0, False,
                                 cert_create, cert_force)

    # For now, chain/chained are copies of tls.crt if we created tls.crt.
    # If we created tls.crt self-signed above there's no true chain, but
    # hopefully this lets any server config start up correctly.
    if make_chains:
        c_chain = cert_dir + '/tls.chain.crt'
        c_chained = cert_dir + '/tls.chained.crt'
        for fn in [c_chain, c_chained]:
            info('Copying ' + tls_cert + ' to ' + fn)
            shutil.copy(tls_cert, fn)
            os.chown(fn, 0, 0)


def acme_challenge_integrated(cert_dir, acct_key, csr, challenge_dir, web_service, acme_uid):
    """Execute the ACME challenge in integrated mode, generating a real cert"""

    # TODO: acme-tiny -> cert output -> service $web_service reload
    return


def acme_challenge_standalone(cert_dir, acct_key, csr, challenge_dir, web_service, acme_uid):
    """Execute the ACME challenge in standalone mode, generating a real cert"""

    # TODO: service $web_service stop -> nginx -c /tmp/challenge.conf -> acme-tiny -> stop nginx -> service $web_service start
    return


def ensure_cert_acme(cert_dir, acct_key, csr, subjects, challenge_mode, challenge_dir, acme_uid, web_service, force_cert):
    """Ensure valid cert exists via ACME challenge"""

    # TODO:
    # diffs from ensure_cert_self:
    # 1) cert_force should check for self-signed and <30d expiry as well
    # 2) cert_create should invoke acme_challenge_MODE()
    # 3) creation of chain+chained file will be different and more-complex
    return


def acme_setup(id, acme_uid, subjects, challenge_mode, challenge_dir, web_service):
    # Directory structure
    base_dir = '/etc/acme'
    this_dir = base_dir + '/' + id
    key_dir = this_dir + '/key'
    cert_dir = this_dir + '/cert'
    ensure_dir(base_dir, 0o755)
    ensure_dir(this_dir, 0o755)
    ensure_dir(key_dir, 0o711)
    ensure_dir(cert_dir, 0o755)

    # Keys
    acct_key = key_dir + '/acct.key'
    ensure_key(acct_key, acme_uid, 0, 0o400, 4096)
    tls_key = key_dir + '/tls.key'
    force_csr = ensure_key(tls_key, 0, 0, 0o400, 2048)

    # CSR based on tls_key + subjects
    csr = this_dir + '/csr.pem'
    force_cert = ensure_csr(csr,  subjects, tls_key, force_csr)

    if challenge_mode == 'none':
        ensure_cert_self(cert_dir, tls_key, csr, subjects, force_cert)
    else:
        ensure_cert_acme(cert_dir, acct_key, csr, subjects, challenge_mode, challenge_dir, acme_uid, web_service, force_cert)


def main():
    os.umask(022)
    args = parse_options()
    if os.geteuid() != 0 or os.getegid() != 0:
        raise Exception('This script must run as root')
    acme_uid = pwd.getpwnam(args.acme_user).pw_uid
    acme_setup(args.id, acme_uid, args.subjects, args.challenge_mode, args.challenge_dir, args.web_service)


if __name__ == '__main__':
    main()

# vim: set ts=4 sw=4 et:
