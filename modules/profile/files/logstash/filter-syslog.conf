# vim:set sw=2 ts=2 sts=2 et
# Parse syslog input
filter {
  if [type] == "syslog" {

    # General syslog message cleanup
    mutate {
      replace => [ "host", "%{logsource}" ]
      add_tag => [ "syslog", "es" ]
      id => "filter/mutate/syslog/es"
    }

    if [program] == "node" {
        mutate {
          replace => [ "level", "%{severity}" ]
          rename => {
            "msg" => "message"
            "name" => "type"
          }
          # Remove syslog and bunyan added fields
          remove_field => [
              "facility", # syslog
              "hostname", # bunyan
              "logsource", # syslog
              "priority", # syslog
              "program", # syslog
              "severity", # syslog
              "time", # bunyan
              "timestamp", # syslog
              "v" # bunyan
          ]
          id => "filter/mutate/syslog/node"
        }
    } else if [program] =~ /^mjolnir-/ {
      # do not mutate level
    } else {
        mutate {
          # Deprecated. `severity_label` is an artifact of the logstash syslog
          # plugin and should be replaced with `severity` upon migration to kafka
          # logging pipeline.
          add_field => { "level" => "%{severity_label}" }
          id => "filter/mutate/syslog/node_level"
        }
    } # end if [program] == "node"

    mutate {
      # "\n" newline notation in substitution results in "\\n" in output.
      # Using a string with a literal newline works as desired.
      gsub => [ "message", "#012", '
' ]
      id => "filter/mutate/syslog/newline"
    }

    # Strip "message repeated" preamble
    if [message] =~ /^message repeated \d+ times:/ {
      grok {
        match => [
          "message",
          "^message repeated %{NUMBER:repeated} times: \[\s*%{GREEDYDATA:message}\]$"
        ]
        overwrite => [ "message" ]
        named_captures_only => true
        id => "filter/grok/syslog/repeated"
      }
    }

    # Map exception.message to message on php7.2-fpm errors when message field is not present
    if [program] == "php7.2-fpm" {
      if ![message] {
        mutate {
          add_field => { "message" => "%{[exception][message]}"}
          id => "filter/mutate/syslog/php_exception"
        }
      }

      # PHP7 fatals are logged to syslog and fowarded as type:syslog
      # We mutate them so they can appear under type:mediawiki channel:fatal - T234283
      # Messages are logged twice, once by php-fpm and once by wmerrors using php7-fatal-error.php.
      # We want to mangle the wmerrors ones as they contain information about the error
      # 'level' is not available here as it is mutated later in the pipeline.
      if [exception][message] and [severity] == "err" {
        # TODO: remove this (T239867)
        # wtp.* hosts parsoid-php
        # rewrite type so as to not inflate mediawiki fatal logs
        if [host] =~ /^wtp/ {
          mutate {
            replace => [ "type", "parsoid-php" ]
            id => "filter/mutate/syslog/parsoid_php"
          }
        } else {
          mutate {
            replace   => [ "type", "mediawiki" ]
            add_field => { "channel" => "fatal" }
            id => "filter/mutate/syslog/fatal"
          }
        }
      }
    }

    if [program] == "apache2" {
      mutate {
        replace => [ "type",  "apache2" ]
        id => "filter/mutate/syslog/apache2"
      }

      # Parse typical apache error format:
      # [channel:level] [pid N:tid N] MSG? [client HOST:PORT] MSG, referer: URL
      grok {
        match => [
          "message",
          "^\[(%{WORD:channel}?:)?%{LOGLEVEL:level}\]\s+(\[pid %{POSINT}(:tid %{POSINT:thread})?\]\s+)?(?<message_prefix>[^\[]+)?(\[client %{IP:clientip}(:%{POSINT:clientport})?\]\s+)?%{DATA:message}(,\s+referer:\s+%{NOTSPACE:referrer})?$"
        ]
        overwrite => [ "message", "level" ]
        named_captures_only => true
        id => "filter/grok/syslog/apache2"
      }

      if [message_prefix] {
        mutate {
          replace => [ "message", "%{message_prefix}%{message}" ]
          remove_field => [ "message_prefix" ]
          id => "filter/mutate/syslog/message_prefix"
        }
      }

    } # end [program] == "apache2"

    if [program] == "mediawiki" {
      mutate {
        replace => [ "type",  "mediawiki" ]
        id => "filter/mutate/syslog/mw"
      }
      if [message] =~ /^{.*}$/ {
        mutate {
          # Remove syslog added fields
          remove_field => [
              "facility",
              "logsource",
              "priority",
              "program",
              "severity",
              "timestamp"
          ]
          id => "filter/mutate/syslog/mw_remove_fields"
        }
        # Parse message as json to unpack logstash record
        json {
          source => "message"
          id => "filter/json/syslog/mw_parse"
        }
      } else {
        # Mark up the message as JSON that was cut off by the syslog transport
        mutate {
          add_field => { "channel" => "jsonTruncated" }
          add_tag => [ "syslog_truncated" ]
          id => "filter/mutate/syslog/mw_truncated"
        }
      }
    } # end [program] == "mediawiki"

    if [program] == "wdqs" {
      mutate {
        replace => [ "type",  "wdqs" ]
        id => "filter/mutate/syslog/wdqs"
      }

      # nginx access logs
      if [facility_label] == "local7" {
        # https://github.com/wikimedia/operations-puppet/blob/3218df6/modules/wdqs/templates/nginx.erb#L1-L6
        grok {
          match => [
            "message",
            "^\[%{HTTPDATE:http_date}\] .%{WORD:http_method} %{NOTSPACE:message} HTTP/%{NUMBER:httpversion}. %{NUMBER:status} (?:%{NUMBER:response_size}|-) %{QS:referrer} %{QS:user_agent} %{NUMBER:request_time} %{NUMBER:upstream_time} (?:%{IP:clientip}|-) %{IP:remote_addr}$"
          ]
          overwrite => [ "message" ]
          named_captures_only => true
          add_field => { "channel" => "nginx" }
          id => "filter/grok/syslog/wdqs"
        }

        if !("_grokparsefailure" in [tags]) {
          mutate {
            add_field => {
              "message_decoded" => "%{message}"
            }
            id => "filter/mutate/syslog/grok_fail"
          }

          urldecode {
            field => "message_decoded"
            id => "filter/urldecode/syslog/message"
          }
        }

        mutate {
          # Remove syslog added fields
          remove_field => [
              "facility",
              "logsource",
              "priority",
              "program",
              "severity",
              "timestamp"
          ]
          id => "filter/mutate/syslog/remove_fields"
        }
      } # end [facility_label] == "local7"
    } # end [program] == "wdqs"
  }
}
