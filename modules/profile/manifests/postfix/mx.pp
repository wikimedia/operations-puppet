# SPDX-License-Identifier: Apache-2.0
# @summary
#     Setup Postfix and Rspamd on MX hosts
# @example
#     static_transport_maps example
#     gmail:
#       type: 'hash'
#         content: |
#           wikimedia.org smtp:aspmx.l.google.com
# @param config
#     Postfix configuration, *excluding* virtual_alias_maps, transport_maps, and
#     the base Postfix configuration which is generated by this class, then
#     to the Postfix module.
# @param static_transport_maps
#     Postfix transport maps whose values are supplied inline.
# @param dynamic_transport_maps
#     Postfix transport maps whose values are generated elsewhere, i.e. just the
#     path to the generated map on disk.
# @param domain_aliases_generic
#     List of domains which have generic aliases, e.g. postmaster
# @param domain_aliases
#     Hash of domain name to specific domain aliases in Postfix lookup
#     format
# @param rspamd_dkim_keys
#     Hash of DKIM key name to private key value
# @param rspamd_config
#     Rspamd config, passed directly to rspamd module
# @param rspamd_override_config
#     Rspamd config, passed directly to rspamd module after adding
#     trusted networks.
# @param rspamd_sender_discards
#     Sender address patterns to silently discard, these patterns should conform to the Rspamd syntax:
#     https://rspamd.com/doc/modules/multimap.html#regexp-maps
# @param plain_auth_logins
#     Hash of username to hashed password for SMTP plain authenticated relaying,
#     protected by TLS.
# @param trusted_networks
#     List of CIDRs to skip spam checking and relay checks.
# @param mail_aliases
#     Config for script to send wikipedia.org mail aliases to ITS for review
# @param verp_config
#     Config for enabling VERP for wikimedia bounces.
# @param mta_mode
#     General mode of postfix instance: null-client, outbound, or inbound
# @param recipient_discards
#     Recipient addresses to silently discard
# @param verify_domains
#     List of domains, which postfix should verify recipients by using the
#     verify(8) daemon
# @param unverifiable_domains
#     List of domains whose recipients cannot be verified
class profile::postfix::mx (
    Hash                                     $config                 = lookup('profile::postfix::mx::config', { 'default_value' => {} }),
    Profile::Postfix::Static_transport_maps  $static_transport_maps  = lookup('profile::postfix::mx::static_transport_maps', {'default_value' => {}}),
    Profile::Postfix::Dynamic_transport_maps $dynamic_transport_maps = lookup('profile::postfix::mx::dynamic_transport_maps', {'default_value' => {}}),
    Array[Stdlib::Host]                      $domain_aliases_generic = lookup('profile::postfix::mx::domain_aliases_generic', {'default_value' => []}),
    Profile::Postfix::Domain_aliases         $domain_aliases         = lookup('profile::postfix::mx::domain_aliases', {'default_value' => {}}),
    Hash                                     $rspamd_config          = lookup('profile::postfix::mx::rspamd_config', { 'default_value' => {} }),
    Hash                                     $rspamd_override_config = lookup('profile::postfix::mx::rspamd_override_config', { 'default_value' => {} }),
    Hash[String[1], String[1]]               $rspamd_dkim_keys       = lookup('profile::postfix::mx::rspamd_dkim_keys', { 'default_value' => {} }),
    Array[String[1]]                         $rspamd_sender_discards = lookup('profile::postfix::mx::rspamd_sender_discards', {'default_value' => []}),
    Hash[Stdlib::Email, String[1]]           $plain_auth_logins      = lookup('profile::postfix::mx::plain_auth_logins', {'default_value' => {}}),
    Array[Stdlib::IP::Address]               $trusted_networks       = lookup('profile::postfix::mx::trusted_networks', {'default_value' => $::network::constants::aggregate_networks}),
    Optional[Profile::Postfix::Mail_aliases] $mail_aliases           = lookup('profile::postfix::mx::mail_aliases', {'default_value' => undef}),
    Optional[Profile::Postfix::Verp]         $verp_config            = lookup('profile::postfix::mx::verp_config', {'default_value' => undef}),
    Profile::Postfix::Mta_mode               $mta_mode               = lookup('profile::postfix::mx::mta_mode', {'default_value' => 'null-client'}),
    Hash[Stdlib::Email, String[1]]           $recipient_discards     = lookup('profile::postfix::mx::recipient_discards', {'default_value' => {}}),
    Array[Stdlib::Host]                      $verify_domains         = lookup('profile::postfix::mx::verify_domains', {'default_value' => []}),
    Array[Stdlib::Host]                      $unverifiable_domains   = lookup('profile::postfix::mx::unverifiable_domains', {'default_value' => []}),
) {
    $trusted_networks_filtered = $trusted_networks.filter |$x| {
        $x !~ /127.0.0.0|::1/
    }

    $domain_aliases_maps = $domain_aliases.map |$domain, $_| {
        "hash:/etc/postfix/aliases/virtual-${domain}"
    }
    $domain_aliases_generic_maps = $domain_aliases_generic.map |$domain| {
        "hash:/etc/postfix/aliases/virtual-${domain}"
    }
    $static_transport_maps_paths = $static_transport_maps.map |$name, $data| {
        "${data['type']}:/etc/postfix/transport-${name}"
    }
    $dynamic_transport_maps_paths = $dynamic_transport_maps.map |$_, $data| {
        "${data['type']}:${data['path']}"
    }

    # Postfix style with ipv6 networks surrounded by square braces
    $agg_nets = regsubst(
        $trusted_networks,
        '^([a-f0-9:]+)(\/.*)',
        '[\1]\2',
    )

    $recipient_discard_transport_map_path = '/etc/postfix/transport-recipient-discards'
    $recipient_discard_transport_maps_paths = [ "hash:${recipient_discard_transport_map_path}" ]
    postfix::lookup::database { $recipient_discard_transport_map_path:
        content => $recipient_discards.reduce('') |$memo, $v| {
            "${memo}${v[0]} discard:${v[1]}\n"
        },
    }

    if $mta_mode == 'inbound' {
        $verify_domains_path = '/etc/postfix/verify_domains'
        postfix::lookup::database { $verify_domains_path:
            content => $verify_domains.reduce('') |$memo, $domain| {
                "${memo}${domain} reject_unverified_recipient\n"
            },
        }

        $wild_card_verify_domains_path = '/etc/postfix/wild_card_verify_domains'
        postfix::lookup::database { $wild_card_verify_domains_path:
            content => $verify_domains.reduce('') |$memo, $domain| {
                "${memo}@${domain} OK\n"
            },
        }

        $wild_card_unverifiable_domains_path = '/etc/postfix/wild_card_unverifiable_domains'
        postfix::lookup::database { $wild_card_unverifiable_domains_path:
            content => $unverifiable_domains.reduce('') |$memo, $domain| {
                "${memo}@${domain} OK\n"
            },
        }
    }

    $base_config = {
        # Disable any compatibility settings prior to version 3.6, which
        # had the last change in defaults
        compatibility_level              => '3.6',
        mynetworks                       => $agg_nets,
        myhostname                       => $facts['fqdn'],
        inet_interfaces                  => case $mta_mode {
            'null-client': { ['loopback-only'] }
            default:       { ['all'] }
        },
        # Override the default 'mail' syslog facility so our rsyslog config
        # doesn't result in double logging.
        syslog_facility                  => 'local0',
        # Require TLS to advertise SMTP auth
        smtpd_tls_auth_only              => 'yes',
        header_checks                    => ['regexp:/etc/postfix/header_checks'],
        smtpd_sender_restrictions        => [
            'permit_mynetworks',
            'reject_non_fqdn_sender',
            'reject_unknown_sender_domain',
        ],
        smtpd_relay_restrictions         => [
            'permit_mynetworks',
            'permit_sasl_authenticated',
            'reject_unauth_destination',
        ],
        smtpd_recipient_restrictions     => [
            'permit_mynetworks',
            'reject_non_fqdn_recipient',
            'reject_unknown_recipient_domain',
        ],
        smtpd_milters                    => ['unix:/rspamd/milter.sock'],
        # Require mail clients to say helo
        smtpd_helo_required              => 'yes',
        smtpd_helo_restrictions          => [
            'permit_mynetworks',
            'reject_non_fqdn_helo_hostname',
            'reject_invalid_helo_hostname',
        ],
        # Require mail clients to use standard envelope commands
        strict_rfc821_envelopes          => 'yes',
        # Reject egress mail that is not configured
        smtpd_reject_unlisted_sender     => 'yes',
        transport_maps                   => $static_transport_maps_paths +
                                            $dynamic_transport_maps_paths +
                                            $recipient_discard_transport_maps_paths,
        parent_domain_matches_subdomains => ['debug_peer_list'],
        # Prevent smtp smuggling, https://www.postfix.org/smtp-smuggling.html
        smtpd_forbid_bare_newline        => 'normalize',
    }

    if length($domain_aliases_maps + $domain_aliases_generic_maps) > 0 {
        $virtual_alias_maps = {
            virtual_alias_maps => $domain_aliases_maps +
                                  $domain_aliases_generic_maps,
        }
    } else {
        $virtual_alias_maps = {}
    }

    if 'virtual_alias_maps' in $config {
        fail('virtual_alias_maps may not be provided in $config, as it will be masked by domain_aliases{,_generic}')
    }
    if 'transport_maps' in $config {
        fail('transport_maps may not be provided in $config, as it will be masked by $transport_maps_{static,dynamic}')
    }

    # TLS Config
    $acme_chief_cert = $mta_mode ? {
        'inbound'     => 'mx-in',
        'outbound'    => 'mx-out',
        'null-client' => 'mx-null-client',
        default       => fail('mta_mode not supported'),
    }
    $acme_chief_host = lookup('acmechief_host') # lint:ignore:wmf_styleguide
    $cert_resources = ['rsa-2048', 'ec-prime256v1'].map |$tls_key_type| {
        profile::postfix::acme_chief_cert(
            $acme_chief_host,
            $acme_chief_cert,
            $tls_key_type,
        )
    }
    $cert_resources.each |$rsc| {
        # Restart postfix on cert changes
        $rsc ~> Service['postfix']
    }
    $tls_config = {
        smtpd_tls_chain_files =>
            $cert_resources.map |$rsc| {
                $rsc['path']
            },
    }

    if $plain_auth_logins != {} {
        $dovecot_config = {
            smtpd_sasl_type                 => 'dovecot',
            smtpd_sasl_path                 => 'private/auth',
            smtpd_sasl_auth_enable          => 'yes',
            smtpd_sasl_authenticated_header => 'yes',
            smtpd_sender_login_maps         => [
                'hash:/etc/postfix/controlled_envelope_senders'
            ],
            smtpd_sender_restrictions       =>
                $base_config['smtpd_sender_restrictions'] +
                ['reject_authenticated_sender_login_mismatch'],
        }
        ensure_packages(['dovecot-core'])
        file { '/etc/dovecot/plain_auth_logins':
            ensure  => present,
            owner   => 'root',
            group   => 'dovecot',
            mode    => '0440',
            content => Sensitive($plain_auth_logins.reduce('') |$memo, $v| {
                "${memo}${v[0]}:${v[1]}\n"
            }),
            require => Package['dovecot-core']
        }

        file { '/etc/dovecot':
          ensure  => directory,
          mode    => '0755',
          recurse => true,
          purge   => true,
          force   => true,
        }

        file { '/etc/dovecot/dovecot.conf':
          ensure  => file,
          mode    => '0755',
          content => @(EOF),
              auth_mechanisms = plain
              passdb {
                driver = passwd-file
                args = scheme=CRYPT username_format=%u /etc/dovecot/plain_auth_logins
              }
              service auth {
                # Postfix smtp-auth
                unix_listener /var/spool/postfix/private/auth {
                  mode = 0660
                  user = postfix
                  group = postfix
                }
              }
              | EOF
          notify  => Service['dovecot'],
          require => File['/var/spool/postfix'],
        }
        service {'dovecot':}
        postfix::lookup::database { '/etc/postfix/controlled_envelope_senders':
            content => $plain_auth_logins.keys().reduce('') |$memo, $addr| {
                "${memo}${addr} ${addr}\n"
            },
        }
    } else {
        $dovecot_config = {}
    }

    $mta_mode_config = $mta_mode ? {
        'inbound'     => {
            relay_recipient_maps         => get($config, 'relay_recipient_maps', []) +
                                            ["hash:${wild_card_unverifiable_domains_path}"] +
                                            ["hash:${wild_card_verify_domains_path}"],
            smtpd_recipient_restrictions => get($base_config, 'smtpd_recipient_restrictions') +
                                            ["check_recipient_access hash:${verify_domains_path}"],
        },
        'outbound'    => {},
        'null-client' => {},
        default       => fail('mta_mode not supported'),
    }

    # lint:ignore:2sp_soft_tabs
    class { 'postfix':
        # *NOTE*: the order matters, for example $dovecot_config may overwrite
        # params in the $base_config
        * => $config + $base_config + $tls_config + $dovecot_config +
             $virtual_alias_maps +
             $mta_mode_config
    }
    # lint:endignore

    # We need rspamd to create the milter socket, before installing postfix
    Class['Rspamd'] -> Class['Postfix']

    monitoring::service { 'smtp':
        description   => 'Postfix SMTP',
        check_command => 'check_smtp_tls_le',
        notes_url     => 'https://wikitech.wikimedia.org/wiki/Mail#Troubleshooting',
    }

    firewall::service { 'smtp':
        proto => 'tcp',
        port  => '25',
    }

    if $mail_aliases {
        file { '/etc/mail-aliases.conf':
            ensure  => present,
            mode    => '0444',
            content => epp(
                'profile/postfix/mx/mail-aliases.conf.epp',
                {
                    'subject' => $mail_aliases['subject'],
                    'rcpt'    => $mail_aliases['rcpt'],
                    'path'    => $mail_aliases['path'],
                }
            ),
        }

        file { '/usr/local/bin/mail-aliases':
            ensure  => present,
            mode    => '0555',
            source  => 'puppet:///modules/profile/postfix/mx/mail-aliases.sh',
            require => File['/etc/mail-aliases.conf'],
        }

        systemd::timer::job { 'mail-aliases':
            ensure             => present,
            user               => 'postfix',
            description        => 'Emails the wikimedia.org mail alias file to ITS once per week',
            command            => '/usr/local/bin/mail-aliases',
            interval           => {'start' => 'OnCalendar', 'interval' => 'weekly'},
            monitoring_enabled => false,
            logging_enabled    => false,
            require            => File['/usr/local/bin/mail-aliases'],
        }
    }

    logrotate::conf { 'postfix':
        ensure  => present,
        content => @(EOF),
            # Managed by Puppet
            # logrotate(8) config
            /var/log/postfix.log {
                daily
                dateext
                dateyesterday
                rotate 60
                missingok
                nocreate
                compress
                delaycompress
                sharedscripts
                postrotate
                    systemctl kill -s HUP rsyslog.service
                endscript
            }
            | EOF
    }

    rsyslog::conf { 'postfix':
        priority => 20,
        content  => @(EOF),
            # Managed by Puppet
            # rsyslog.conf(5) config
            if ($programname startswith 'postfix') then {
                action(type="omfile" file="/var/log/postfix.log")
            }
            | EOF
    }

    class { 'prometheus_postfix_exporter': }

    # TODO: Move exim logic to profile::base
    package { [
        'exim4',
        'exim4-base',
        'exim4-config',
        'exim4-daemon-heavy',
        'exim4-daemon-light',
    ]:
        ensure => purged,
        notify => Exec['kill-exim4'],
        before => [
            Package['postfix'],
            Package['prometheus-postfix-exporter'],
        ]
    }

    exec { 'kill-exim4':
        command     => '/usr/bin/systemctl kill exim4',
        refreshonly => true,
    }

    # Install an email debugging tool
    ensure_packages(['swaks'])

    file { '/etc/aliases':
        ensure  => file,
        mode    => '0444',
        content => @(EOF),
            mailer-daemon: root
            postmaster: root
            nobody: root
            hostmaster: root
            usenet: root
            news: root
            webmaster: root
            www: root
            ftp: root
            abuse: root
            noc: root
            security: root
            root: root@wikimedia.org
            | EOF
        notify  => Exec['newaliases'],
    }

    exec { 'newaliases':
        command     => '/usr/bin/newaliases',
        refreshonly => true,
    }

    file { '/etc/postfix':
        ensure  => directory,
        mode    => '0755',
        # let debian manage these configish files, if we wipe them out, postfix
        # does not start.
        ignore  => [
            'makedefs.out',
            'post-install',
            'postfix-files',
            'postfix-script',
        ],
        recurse => true,
        purge   => true,
        force   => true,
    }

    $rspamd_base_config = {
        milter_headers => {
            use => [
                'x-spam-status',
                'authentication-results',
            ],
        },
        multimap => {
            trusted_networks => {
                type      => 'ip',
                map       => 'file:///var/lib/rspamd/trusted_networks.map',
                symbol    => 'TRUSTED_NETWORKS',
                action    => 'accept',
                prefilter => true,
            },
            sender_discards => {
                type      => 'from',
                map       => 'file:///var/lib/rspamd/sender_discards.map',
                symbol    => 'SENDER_DISCARDS',
                action    => 'discard',
                prefilter => true,
                regexp    => true,
            }
        },
        actions => {
            discard => {
                flags => ['no_threshold'],
            }
        },
        # NOTE: mode 666 is okay here because the parent directory is only accessible
        # by postfix and rspamd, we need 666 so that postfix can write to the
        # socket which has an ownership of _rspamd:_rspamd, we can't easily
        # change the ownership because we install rspamd first.
        'worker-proxy.inc' => {
            bind_socket => '/var/spool/postfix/rspamd/milter.sock mode=0666',
        },
    }

    file { '/var/spool/postfix':
        ensure => directory,
        mode   => '0755',
    }

    file { '/var/spool/postfix/rspamd':
        ensure  => directory,
        owner   => 'postfix',
        group   => '_rspamd',
        mode    => '0770',
        # Needed for postfix user & _rspamd group
        require => [
            Package['postfix'],
            Package['rspamd'],
        ],
    }

    file { '/var/lib/rspamd/sender_discards.map':
        ensure  => present,
        mode    => '0444',
        content => $rspamd_sender_discards.reduce('') |$memo, $v| {
            "${memo}${v}\n"
        },
        # needed to create the /var/lib/rspamd dir
        require => Package['rspamd'],
    }

    # Skip spam checking for trusted networks, this is needed in addition to
    # local_addrs, which skips other Rspamd checks.
    file { '/var/lib/rspamd/trusted_networks.map':
        ensure  => present,
        mode    => '0444',
        content => $trusted_networks_filtered.reduce('') |$memo, $v| {
            "${memo}${v}\n"
        },
        # needed to create the /var/lib/rspamd dir
        require => Package['rspamd'],
    }

    class { 'rspamd':
        manage_package_repo => false,
        config              => $rspamd_base_config + $rspamd_config,
        require             => File['/var/spool/postfix'],
    }

    profile::auto_restarts::service { 'rspamd': }

    $rspamd_override_config_base =  {
        'options.inc' => {
            'local_addrs' => $trusted_networks_filtered,
        }
    }

    rspamd::create_config_file_resources(
        $rspamd_override_config_base + $rspamd_override_config, { mode => 'override' }
    )

    if $rspamd_dkim_keys != {} {
        file { '/etc/rspamd/dkim':
            ensure  => directory,
            mode    => '0755',
            require => Package['rspamd'],
        }

        $rspamd_dkim_keys.each |$name, $key| {
            file { "/etc/rspamd/dkim/${name}":
              ensure  => file,
              owner   => '_rspamd',
              group   => '_rspamd',
              mode    => '0400',
              content => Sensitive($key),
              require => Package['rspamd'],
              notify  => Service['rspamd'],
            }
        }
    }

    postfix::lookup::database { '/etc/postfix/header_checks':
        content => @(EOF),
            # Strip incoming spam headers
            /^X-Spam-Score:.*/			IGNORE
            | EOF
    }

    if $verp_config {
        postfix::master { 'wiki-verp-bounce-handler/unix':
            chroot       => 'n',
            unprivileged => 'n',
            # The command must not have a trailing newline, so we chomp it off
            command      => epp(
                'profile/postfix/mx/verp_cmd.epp',
                {
                    'post_connect_server' => $verp_config['post_connect_server'],
                    'bounce_post_url'     => $verp_config['bounce_post_url'],
                }
            ).chomp,
        }
    }

    file { '/etc/postfix/aliases':
        ensure => directory,
        mode   => '0755',
    }

    $domain_aliases_generic.each |$domain| {
        postfix::lookup::database { "/etc/postfix/aliases/virtual-${domain}":
            content => epp(
                'profile/postfix/mx/generic_aliases.epp',
                { domain => $domain }
            )
        }
    }
    $domain_aliases.each |$domain, $virtual_aliases| {
        postfix::lookup::database { "/etc/postfix/aliases/virtual-${domain}":
            content => epp(
                'profile/postfix/mx/virtual-aliases.epp',
                { 'virtual_aliases' => $virtual_aliases }
            ),
        }
    }
    $static_transport_maps.each |$name, $data| {
        postfix::lookup::database { "/etc/postfix/transport-${name}":
            content => $data['content']
        }
    }
}
