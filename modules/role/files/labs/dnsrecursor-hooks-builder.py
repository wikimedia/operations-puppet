#!/usr/bin/python
import os
import sys
import yaml
import argparse
import itertools

from keystoneclient.session import Session as KeystoneSession
from keystoneclient.auth.identity.v2 import Password as KeystonePassword
from keystoneclient.client import Client as KeystoneClient

from novaclient import client as novaclient

argparser = argparse.ArgumentParser()
argparser.add_argument(
    '--config-file',
    help='Path to config file',
    default='/etc/labs-dnsrecursor-hooks-builder-config.yaml',
    type=argparse.FileType('r')
)
argparser.add_argument(
    '--check-changes-only',
    help='Exit with 0 if there are no changes and 1 if there are changes. Do not write to file',
    action='store_true'
)

LUA_LINE_TEMPLATE = '{table}["{key}"] = "{value}"\n'
LUA_LINE_TEMPLATE_COMMENT = '{table}["{key}"] = "{value}" -- {comment}\n'
INSTANCE_DNS_SUFFIX = '.' + config['site'] + '.' + config['tld'] + '.'

args = argparser.parse_args()
config = yaml.safe_load(args.config_file)

auth = KeystonePassword(
    auth_url=config['nova_api_url'],
    username=config['username'],
    password=config['password'],
    tenant_name=config['admin_project_name']
)
keystoneClient = KeystoneClient(
    session=KeystoneSession(auth=auth), endpoint=config['nova_api_url'])

projects = []
for tenant in keystoneClient.tenants.list():
    projects.append(tenant.name)

aliases = {}
for project in projects:
    client = novaclient.Client(
        "1.1",
        config['username'],
        config['password'],
        project,
        config['nova_api_url']
    )

    for server in client.servers.list():
        serverAddresses = {}
        try:
            private = [
                str(ip['addr']) for ip in server.addresses['public']
                if ip['OS-EXT-IPS:type'] == 'fixed'
            ]
            public = [
                str(ip['addr']) for ip in server.addresses['public']
                if ip['OS-EXT-IPS:type'] == 'floating'
            ]
            if public:
                # Match all possible public IPs to all possible private ones
                # Technically there can be more than one floating IP and more than one private IP
                # Although this is never practically the case...
                aliases[server.name] = list(itertools.product(public, private))
        except KeyError:
            # This can happen if a server doesn't (yet) have any addresses, while it's being
            # constructed.  In which case we simply harmlessly ignore it.
            pass

output = """-- THIS FILE IS GENERATED BY dnsrecursor-hooks-builder.py, RUN BY PUPPET
-- Queries hitting this code (i.e., the recursors) are from internal labs machines.
--
-- The metal entries are handled here rather than in designate because it's easier to puppetize
-- this file than to insert things into designate from puppet, and currently puppet/hiera contains
-- the canonical representation of bare metal hosts and names.
--
-- The IP aliasing is handled here because it is dynamic, we need to return different records
-- to the outside world than to internal machines. The problem this solves is that labs instances
-- without public IPs cannot connect to labs public IPs, only private IPs.

IPAliases = {}
MetalARecords = {}
MetalPTRRecords = {}
"""
# Sort to prevent flapping around due to random ordering
for name in sorted(aliases.keys()):
    ips = aliases[name]
    for public, private in ips:
        output += LUA_LINE_TEMPLATE_COMMENT.format(
            table='IPAliases',
            key=public,
            value=private,
            comment=name
        )

for instance_name in sorted(config['metal']):
    instance_details = config['metal'][instance_name]
    IPv4 = instance_details['IPv4']
    project = instance_details['project']
    output += LUA_LINE_TEMPLATE.format(
        table='MetalARecords',
        key=instance_name + '.' + INSTANCE_DNS_SUFFIX,
        value=IPv4
    ) + LUA_LINE_TEMPLATE.format(
        table='MetalARecords',
        key=instance_name + '.' + project + INSTANCE_DNS_SUFFIX,
        value=IPv4
    ) + LUA_LINE_TEMPLATE.format(
        table='MetalPTRRecords',
        key='.'.join(list(reversed(IPv4.split('.')))) + '.in-addr.arpa.',
        value=instance_name + '.' + project + INSTANCE_DNS_SUFFIX
    ) + '\n'

output += """
function postresolve (remoteip, domain, qtype, records, origrcode)
    if ((qtype == pdns.PTR or qtype == pdns.ANY) and MetalPTRRecords[domain]) then
        return 0, {{qtype=pdns.PTR, content=(MetalPTRRecords[domain]), ttl=300}}
    end

    if ((qtype == pdns.A or qtype == pdns.ANY) and MetalARecords[domain]) then
        return 0, {{qtype=pdns.A, content=(MetalARecords[domain]), ttl=300}}
    end

    -- Prevent NXDOMAIN if the domain exists, we just don't have a record of the matching type.
    if (MetalARecords[domain] or MetalPTRRecords[domain]) then
        return 0, records
    end

    for key, val in ipairs(records)
    do
        if (IPAliases[val.content] and val.qtype == pdns.A) then
            val.content = IPAliases[val.content]
            setvariable()
        end
    end

    return origrcode, records
end

"""

if 'extra_records' in config:
    output += 'extra_records = {}\n'
    extra_records = config['extra_records']

    for q in sorted(extra_records.keys()):
        output += LUA_LINE_TEMPLATE.format(
            table='extra_records',
            key=q,
            value=extra_records[q],
            comment=q
        )

    output += """
function preresolve(remoteip, domain, qtype)
    if extra_records[domain]
    then
        return 0, {
            {qtype=pdns.A, content=extra_records[domain], ttl=300, place="1"},
        }
    end
    return -1, {}
end
"""

if os.path.exists(config['output_path']):
    with open(config['output_path']) as f:
        current_contents = f.read()
else:
    current_contents = ""

if output == current_contents:
    # Do nothing!
    if args.check_changes_only:
        sys.exit(0)
else:
    if args.check_changes_only:
        sys.exit(1)
    with open(config['output_path'], 'w') as f:
        f.write(output)
