#!/usr/bin/perl

# Copyright 2016 Faidon Liambotis
# Copyright 2016 Wikimedia Foundation, Inc.
#
# This nagios plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
# It may be used, redistributed and/or modified under the terms of the GNU
# General Public Licence (see http://www.fsf.org/licensing/licenses/gpl.txt).
#
# Example usage:
#   check_bgp -H cr1-eqdfw.wikimedia.org -c s3cr3t
#   check_bgp -H cr1-eqdfw.wikimedia.org -c s3cr3t -t 3600
#   check_bgp -H cr1-eqdfw.wikimedia.org -c s3cr3t -t 3600 --critasn 1299,2914,6461

package Local::CheckBGP;

use strict;
use warnings;
use Nagios::Plugin::Getopt;
use Nagios::Plugin::Functions;
use Net::SNMP;
use Time::Duration;

# this not exactly great; this isn't a very OO-package, but ePN restricts the
# use of global variables, so package variables should do, for now.
our ( $ng,   $session, %critASN );
our ( @crit, @warn,    @ok );

sub init {
    ( @crit, @warn, @ok ) = ();

    $ng = Nagios::Plugin::Getopt->new(
        usage   => 'Usage: %s -H <host> -p <port> -c <community>',
        version => 1,
        blurb   => 'Connects to a router and checks their BGP peerings',
    );

    $ng->arg(
        spec     => 'host|H=s',
        help     => 'Hostname or IP address of the server to check against',
        required => 1,
    );
    $ng->arg(
        spec    => 'port|p=i',
        help    => 'SNMP port, default: %s',
        default => 161,
    );
    $ng->arg(
        spec    => 'community|c=s',
        help    => 'SNMP community to use, default: %s',
        default => 'public',
    );
    $ng->arg(
        spec    => 'threshold|t=i',
        help    => 'Time threshold after which to warn, default: %s',
        default => 7 * 24 * 60 * 60,
    );
    $ng->arg(
        spec    => 'critasn=s',
        help    => 'Comma-separated list of ASNs to raise CRITICAL for',
        default => '',
    );

    $ng->getopts;

    # split critasn into a hash, so that we can check against with exists
    %critASN = map { $_ => 1 } split( /,/, $ng->critasn );
}

sub session {
    ( $session, my $error ) = Net::SNMP->session(
        -hostname  => $ng->host,
        -community => $ng->community,
        -port      => $ng->port,
        -version   => 'snmpv2c',
    );
    unless ( defined $session ) {
        nagios_exit( CRITICAL, $error );
    }

}

sub collect {

    # BGP4-MIB
    my %name2oid = (

        # bgpPeerEntry
        bgpPeerIdentifier                    => '1.3.6.1.2.1.15.3.1.1',
        bgpPeerState                         => '1.3.6.1.2.1.15.3.1.2',
        bgpPeerAdminStatus                   => '1.3.6.1.2.1.15.3.1.3',
        bgpPeerNegotiatedVersion             => '1.3.6.1.2.1.15.3.1.4',
        bgpPeerLocalAddr                     => '1.3.6.1.2.1.15.3.1.5',
        bgpPeerLocalPort                     => '1.3.6.1.2.1.15.3.1.6',
        bgpPeerRemoteAddr                    => '1.3.6.1.2.1.15.3.1.7',
        bgpPeerRemotePort                    => '1.3.6.1.2.1.15.3.1.8',
        bgpPeerRemoteAs                      => '1.3.6.1.2.1.15.3.1.9',
        bgpPeerInUpdates                     => '1.3.6.1.2.1.15.3.1.10',
        bgpPeerOutUpdates                    => '1.3.6.1.2.1.15.3.1.11',
        bgpPeerInTotalMessages               => '1.3.6.1.2.1.15.3.1.12',
        bgpPeerOutTotalMessages              => '1.3.6.1.2.1.15.3.1.13',
        bgpPeerLastError                     => '1.3.6.1.2.1.15.3.1.14',
        bgpPeerFsmEstablishedTransitions     => '1.3.6.1.2.1.15.3.1.15',
        bgpPeerFsmEstablishedTime            => '1.3.6.1.2.1.15.3.1.16',
        bgpPeerConnectRetryInterval          => '1.3.6.1.2.1.15.3.1.17',
        bgpPeerHoldTime                      => '1.3.6.1.2.1.15.3.1.18',
        bgpPeerKeepAlive                     => '1.3.6.1.2.1.15.3.1.19',
        bgpPeerHoldTimeConfigured            => '1.3.6.1.2.1.15.3.1.20',
        bgpPeerKeepAliveConfigured           => '1.3.6.1.2.1.15.3.1.21',
        bgpPeerMinASOriginationInterval      => '1.3.6.1.2.1.15.3.1.22',
        bgpPeerMinRouteAdvertisementInterval => '1.3.6.1.2.1.15.3.1.23',
        bgpPeerInUpdateElapsedTime           => '1.3.6.1.2.1.15.3.1.24',
    );
    my @bgpPeerState = qw(
      None     Idle        Connect Active
      OpenSent OpenConfirm Established);

    my %bgpPeers;
    my %counts = (qw/up 0 down 0 shutdown 0/);

    # request a few attributes in as many bulk queries, then sort them out into
    # %bgpPeers keyed by the peer's IP address and by OID
    my @requested = qw/bgpPeerRemoteAs bgpPeerState bgpPeerFsmEstablishedTime/;
    foreach my $identifier (@requested) {
        my $oid      = $name2oid{$identifier};
        my $response = $session->get_table($oid);
        unless ($response) {
            nagios_exit( CRITICAL, 'Error while polling: ' . $session->error );
        }

        while ( my ( $peer, $value ) = each %{$response} ) {

            # strip the oid prefix from the key, leaving only the IP in place
            $peer =~ s/^\Q${oid}.\E//;
            $value = $bgpPeerState[$value]
              if $identifier eq 'bgpPeerState';
            $bgpPeers{$peer}{$identifier} = $value;
        }
    }

    # now iterate over the %bgpPeers hash and:
    # - increment up/down/shutdown counters (for OK/verbose)
    # - raise WARN/CRIT in case of failures
    foreach my $peer ( keys %bgpPeers ) {
        my $state    = $bgpPeers{$peer}{bgpPeerState};
        my $asn      = $bgpPeers{$peer}{bgpPeerRemoteAs};
        my $duration = int $bgpPeers{$peer}{bgpPeerFsmEstablishedTime};

        if ( $state eq 'Established' ) {
            $counts{up}++;
        }
        elsif ( $state eq 'Idle' ) {
            $counts{shutdown}++;
        }
        else {
            $counts{down}++;

            # raise a CRIT if the peer's ASN is in the "critical ASN" list
            if ( exists $critASN{$asn} ) {
                push @crit, "AS$asn: $state (important)";
            }

            # otherwise, raise a WARN if this peer has been down for some time
            elsif ( $duration > $ng->threshold ) {
                my $human_duration = concise( duration($duration) );
                push @warn, "AS$asn: $state (for $human_duration)";
            }
        }
    }

    # returns something like: "up: 220, down: 1, shutdown: 0"
    push @ok, join( ', ', map { "$_: $counts{$_}" } qw/up down shutdown/ );
}

sub run {
    init;
    session;
    collect;

    print join( "\n", @ok ), "\n" if $ng->verbose;

    nagios_exit(
        check_messages(
            critical => \@crit,
            warning  => \@warn,
            ok       => \@ok,
            join     => ', ',
        )
    );
}

# call run() if are we running interactively or via ePN
__PACKAGE__->run() if ( !caller || (caller)[0] eq 'Embed::Persistent' );

1;

# vim: ts=4 sw=4 sts=4 et
