#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  vbench - VisualEditor benchmarking tool
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  usage: vbench [--host HOST] [--port PORT] [--repeat N] [--log-requests]
                [--write] [--display DISPLAY] [--latency] URL

  positional arguments:
    URL                URL to load

  optional arguments:
    -h, --help         show this help message and exit
    --host HOST        Chromium host (default: localhost)
    --port PORT        Chromium port (default: 9222)
    --repeat N         times to repeat (default: 5)
    --log-requests     log uncached network requests
    --write            save profiling data as .cpuprofile files.
    --display DISPLAY  set device display metrics to WIDTHxHEIGHT or
                       WIDTHxHEIGHT*SCALE_FACTOR.
    --latency          simulate realistic network conditions

  Copyright 2015 Ori Livneh <ori@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
from __future__ import division, print_function

import sys
reload(sys)
sys.setdefaultencoding('utf-8')

import argparse
import functools
import itertools
import json
import logging
import re
import string
import time
import urllib2
import weakref

try:
    from twisted.internet import defer, reactor
    from twisted.python.log import PythonLoggingObserver

    from autobahn.twisted.websocket import (WebSocketClientProtocol,
                                            WebSocketClientFactory)
except ImportError:
    print('vbench requires autobahn (https://pypi.python.org/pypi/autobahn/) '
          'and twisted (https://pypi.python.org/pypi/Twisted/).')
    sys.exit(1)


# FIXME: Make this configurable.
JS = '''
    window.onload = function () {
        mw.trackSubscribe( 'event.Edit', function ( topic, event ) {
            switch ( event.action ) {
            case 'init':
                console.profile();
                break;
            case 'ready':
                console.profileEnd();
                break;
            }
        } );
        setTimeout( function () {
              $('#ca-ve-edit').click();
        }, 0 );
    };
'''


class ChromeException(Exception):
    pass


class HighlightingFormatter(logging.Formatter):

    RE = re.compile(r'(?P<markup>(\*)|(_))(?P<word>\S+)(?(2)\*)(?(3)_)')
    YELLOW, WHITE, RESET = '\033[93m', '\033[1;37m', '\033[0m'

    def __init__(self, fmt='[_%(asctime)s_] %(message)s', date_fmt='%H:%M:%S',
                 use_color=False):
        if use_color:
            self.subs = {'*': self.WHITE, '_': self.YELLOW, 'end': self.RESET}
        else:
            self.subs = {}
        fmt = self.highlight(fmt)
        super(HighlightingFormatter, self).__init__(fmt, '%I:%M:%S')

    def repl(self, match):
        start = self.subs.get(match.group('markup'), '')
        end = self.subs.get('end', '')
        return start + match.group('word') + end

    def highlight(self, s):
        return self.RE.sub(self.repl, s)
        return super(HighlightingFormatter, self).format(record)

    def format(self, record):
        record.msg = self.highlight(record.msg)
        return super(HighlightingFormatter, self).format(record)


log = logging.getLogger('vbench')
log.setLevel(logging.DEBUG)

is_tty = sys.stdout.isatty()
stdout_handler = logging.StreamHandler(stream=sys.stdout)
stdout_handler.setFormatter(HighlightingFormatter(use_color=is_tty))
log.addHandler(stdout_handler)
if not is_tty:
    stderr_handler = logging.StreamHandler(stream=sys.stderr)
    stderr_handler.setFormatter(HighlightingFormatter(use_color=True))
    log.addHandler(stderr_handler)


def mean(data):
    """Compute arithmetic mean ("average") of data."""
    data = list(data)
    n = len(data)
    if not n:
        raise ValueError('cannot compute mean of empty set')
    return sum(data) / n


def median(data):
    """Compute median (middle value) of data."""
    data = list(data)
    n = len(data)
    if not n:
        raise ValueError('cannot compute median of empty set')
    data.sort()
    i = n // 2
    return data[i] if n % 2 == 1 else (data[i - 1] + data[i]) / 2


def std(data):
    """Compute the population standard deviation."""
    data = list(data)
    n = len(data)
    if n == 0:
        raise ValueError('cannot compute stdev of empty set')
    m = mean(data)
    ss = sum((x - m) ** 2 for x in data)
    return (ss / n) ** 0.5


def parse_display_opts(opt_string):
    """Parse display options in format WIDTHxHEIGHT or WIDTHxHEIGHT*FACTOR."""
    opts = {'deviceScaleFactor': 1, 'emulateViewport': False,
            'fitWindow': False, 'mobile': False}
    match = re.match(r'(?P<width>\d+)x(?P<height>\d+)(\*(?P<deviceScaleFactor'
                     r'>\d+))?', opt_string)
    if match is None:
        raise ValueError('Invalid display options string.')
    opts.update(((k, int(v)) for k, v in match.groupdict().items()))
    return opts


def upper_first(s):
    """Returns a copy of a string with the first letter capitalized."""
    return s[0:1].upper() + s[1:]


def summarize(series):
    """Calculate summary statistics for a population."""
    return [(f.__name__, f(series)) for f in (min, max, mean, median, std)]


def highlight(*args):
    return WHITE + ''.join(map(str, args)) + RESET


def format_summary(summary):
    """Pretty-print summary statistics."""
    items = ('%s: %s' % (k, highlight(round(v, 2), 'ms')) for k, v in summary)
    return ''.join(string.ljust(item, 30) for item in items)


class ChromeCPUProfile(object):
    """Represents the result of a Chrome CPU profiler run."""

    def __init__(self, data):
        self.data = data
        self.cpu_time = self.get_cpu_time()
        self.wall_time = self.get_wall_time()

    def grep(self, function_name, root=None):
        """Search the trace for a function by name."""
        matches = []
        root = root or self.data['head']
        if root.get('functionName') == function_name:
            matches.append(root)
        for child in root.get('children', ()):
            matches.extend(self.grep(function_name, child))
        return matches

    def get_cpu_time(self):
        """Get total CPU time for the trace."""
        idle = self.grep('(idle)')[0]
        idle_samples = idle['hitCount']
        all_samples = len(self.data['samples'])
        percent_active = 100.0 * (all_samples - idle_samples) / all_samples
        total_time = self.data['timestamps'][-1] - self.data['timestamps'][0]
        return (percent_active * total_time) / 1e5

    def get_wall_time(self):
        """Get total wall-clock time for the trace."""
        return (self.data['endTime'] - self.data['startTime']) * 1e3


class ChromeRemoteDebuggingDomain(object):
    """Represents a Chrome Remote Debugging API domain."""

    def __init__(self, domain, proto):
        self.domain = upper_first(domain)
        self.proto = weakref.proxy(proto)

    def __getattr__(self, name):
        command = self.domain + '.' + name
        return functools.partial(self.proto.sendCommand, command)


class ChromeRemoteDebuggingProtocol(WebSocketClientProtocol):
    """Protocol for communicating with Chrome via the Remote Debugging API."""

    def __init__(self):
        for domain in ('page', 'network', 'profiler'):
            self.__dict__[domain] = ChromeRemoteDebuggingDomain(domain, self)

    def sendCommand(self, method, **params):
        id = next(self.message_ids)
        deferred = self.deferreds[id] = defer.Deferred()
        command = {'id': id, 'method': method, 'params': params}
        self.sendMessage(json.dumps(command))
        return deferred

    def onConnect(self, response):
        self.message_ids = itertools.count()
        self.requests = {}
        self.deferreds = {}
        self.cpu_times = []
        self.wall_times = []

    @defer.inlineCallbacks
    def onOpen(self):
        log.info('Loading *%s*...', self.factory.target_url)

        yield self.page.enable()
        yield self.network.enable()
        yield self.profiler.enable()
        yield self.page.addScriptToEvaluateOnLoad(scriptSource=JS)
        yield self.profiler.setSamplingInterval(interval=100)

        if self.factory.display:
            yield self.page.setDeviceMetricsOverride(**self.factory.display)

        if self.factory.latency:
            # FIXME: Make this configurable.
            throughput = 256 * 1024
            yield self.network.emulateNetworkConditions(
                offline=False, latency=100, downloadThroughput=throughput,
                uploadThroughput=throughput)

        yield self.onProfilerReady()

    def onNetworkRequestServedFromCache(self, params=None):
        del self.requests[params['requestId']]

    def onNetworkRequestWillBeSent(self, params=None):
        self.requests[params['requestId']] = params['request']

    @defer.inlineCallbacks
    def onProfilerReady(self, params=None):
        yield self.network.clearBrowserCache()
        yield self.page.navigate(url=self.factory.target_url)

    def writeProfilerData(self, data):
        name = '%s.%d.cpuprofile' % (data.get('title', 'profile'), time.time())
        with open(name, 'w') as f:
            json.dump(data, f)

    def onProfilerConsoleProfileStarted(self, params=None):
        self.requests.clear()

    def onProfilerConsoleProfileFinished(self, params=None):
        data = params['profile']

        if self.factory.write:
            self.writeProfilerData(data)

        profile = ChromeCPUProfile(data)

        if self.factory.log_requests:
            for req in self.requests.values():
                log.info('[*%(method)s*] %(url)s', req)

        self.cpu_times.append(profile.cpu_time)
        self.wall_times.append(profile.wall_time)

        repeated = len(self.cpu_times)
        if self.factory.repetitions > 1:
            report_template = '{:02d}/{:02d}: CPU: {: >7.2f}  Wall: {: >7.2f}'
            log.info(report_template.format(repeated,
                                            self.factory.repetitions,
                                            profile.cpu_time,
                                            profile.wall_time))
        if repeated < self.factory.repetitions:
            return self.onProfilerReady()
        else:
            reactor.stop()
            self.showSummary()

    def getHandler(self, method):
        object, event = method.split('.')
        handler = 'on' + object + upper_first(event)
        return getattr(self, handler, None)

    def onMessage(self, payload, isBinary):
        message = json.loads(payload.decode('utf-8'))

        id = message.get('id')
        error = message.get('error')
        method = message.get('method')
        params = message.get('params')
        response = message.get('response')
        deferred = self.deferreds.get(id)

        if deferred:
            if error:
                log.error(error)
                return deferred.errback(error)
            else:
                return deferred.callback(response)

        if method:
            handler = self.getHandler(method)
            if handler:
                return handler(params)

    def showSummary(self):
        log.info('CPU:  %s', format_summary(summarize(self.cpu_times)))
        log.info('Wall: %s', format_summary(summarize(self.wall_times)))


class ChromeRemoteDebuggingFactory(WebSocketClientFactory):

    def __init__(self, url, host='localhost', port=9222, write=False,
                 repetitions=5, log_requests=False, display=False,
                 latency=False):
        self.host = host
        self.port = port
        self.repetitions = repetitions
        self.target_url = url.replace('https://', 'http://', 1)  # force HTTP
        self.write = write
        self.log_requests = log_requests
        self.display = display
        self.latency = latency
        try:
            tabs = self.getTabs()
        except IOError:
            raise ChromeException('Could not connect to Chrome on %s:%s'
                                  % (self.host, self.port))
        try:
            tab = next(t for t in tabs if 'webSocketDebuggerUrl' in t)
        except StopIteration:
            raise ChromeException('Chrome does not have any connectable tabs')
        WebSocketClientFactory.__init__(self, tab['webSocketDebuggerUrl'])
        self.protocol = ChromeRemoteDebuggingProtocol

    def getTabs(self):
        req = urllib2.urlopen('http://%s:%s/json' % (self.host, self.port))
        return json.load(req)


ap = argparse.ArgumentParser(fromfile_prefix_chars='@')
ap.add_argument('--host', default='localhost',
                help='Chromium host (default: localhost)')
ap.add_argument('--port', default=9222, type=int,
                help='Chromium port (default: 9222)')
ap.add_argument('--repeat', default=5, metavar='N', type=int,
                dest='repetitions', help='times to repeat (default: 5)')
ap.add_argument('--log-requests', action='store_true', default=False,
                help='log uncached network requests')
ap.add_argument('--write', action='store_true', default=False,
                help='save profiling data as .cpuprofile files.')
ap.add_argument('--display', type=parse_display_opts,
                help='set device display metrics to WIDTHxHEIGHT or '
                     'WIDTHxHEIGHT*SCALE_FACTOR.')
ap.add_argument('--latency', action='store_true', default=False,
                help='simulate realistic network conditions')
ap.add_argument('url', help='URL to load')
args = ap.parse_args()


if __name__ == '__main__':
    observer = PythonLoggingObserver()
    observer.start()
    factory = ChromeRemoteDebuggingFactory(**vars(args))
    reactor.connectTCP(args.host, args.port, factory)
    reactor.run()
