#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  vbench - VisualEditor benchmarking tool
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  usage: vbench [-h] [--host HOST] [--port PORT] [--reps N] [--write] url

  positional arguments:
    url          URL to load

  optional arguments:
    -h, --help    show this help message and exit
    --host HOST   Chromium host (default: 'localhost')
    --port PORT   Chromium port (default: 9222)
    --reps N      repetitions (default: 20)
    --warmups N   warm-up loops (default: 2)
    --write       save profiling data as .cpuprofile files.

  Copyright 2015 Ori Livneh <ori@wikimedia.org>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

"""
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

import argparse
import inspect
import itertools
import json
import logging
import re
import socket
import string
import time
import urllib2

from twisted.internet import defer, reactor
from twisted.python import log

from numpy import mean, median, std

from autobahn.twisted.websocket import (WebSocketClientProtocol,
                                        WebSocketClientFactory)


JS = '''
    window.onload = function () {
        mw.trackSubscribe( 'event.Edit', function ( topic, event ) {
            switch ( event.action ) {
            case 'init':
                console.profile();
                break;
            case 'ready':
                console.profileEnd();
                break;
            }
        } );
        setTimeout( function () {
              $('#ca-ve-edit').click();
        }, 0 );
    };
'''

YELLOW, WHITE, RESET = '\033[93m', '\033[1;37m', '\033[0m'

logging.basicConfig(format='[%s%%(asctime)s%s] %%(message)s' % (YELLOW, RESET),
                    datefmt='%I:%M:%S', level=logging.DEBUG)

measures = (min, max, mean, median, std)

DISPLAY_RE = r'(?P<width>\d+)x(?P<height>\d+)(\*(?P<deviceScaleFactor>\d+))?'


def parse_display_opts(opt_string):
    opts = {
        'deviceScaleFactor': 1,
        'emulateViewport': False,
        'fitWindow': False,
        'mobile': False,
    }
    m = re.match(DISPLAY_RE, opt_string)
    if m is None:
        raise ValueError('"%s" is not a valid display specification. '
                         'The format is WIDTHxHEIGHT*DEPTH' % opt_string)
    opts.update(((k, int(v)) for k, v in m.groupdict().items()))
    return opts


def upper_first(s):
    return s[0:1].upper() + s[1:]


def summarize(series):
    return [(f.__name__, f(series)) for f in measures]


def highlight(*args):
    return WHITE + ''.join(map(str, args)) + RESET


def format_summary(summary):
    items = ('%s: %s' % (k, highlight(round(v, 2), 'ms')) for k, v in summary)
    return ''.join(string.ljust(item, 30) for item in items)


class ChromeCPUProfile(object):

    def __init__(self, data):
        self.data = data
        self.cpu_time = self.get_cpu_time()
        self.wall_time = self.get_wall_time()

    def grep(self, function_name, root=None):
        matches = []
        root = root or self.data['head']
        if root.get('functionName') == function_name:
            matches.append(root)
        for child in root.get('children', ()):
            matches.extend(self.grep(function_name, child))
        return matches

    def get_cpu_time(self):
        idle = self.grep('(idle)')[0]
        idle_samples = idle['hitCount']
        all_samples = len(self.data['samples'])
        percent_active = 100.0 * (all_samples - idle_samples) / all_samples
        total_time = self.data['timestamps'][-1] - self.data['timestamps'][0]
        return (percent_active * total_time) / 1e5

    def get_wall_time(self):
        return (self.data['endTime'] - self.data['startTime']) * 1e3


class ChromeRemoteDebuggingProtocol(WebSocketClientProtocol):

    def sendCommand(self, method, **params):
        id = next(self.message_ids)
        deferred = self.deferreds[id] = defer.Deferred()
        command = {'id': id, 'method': method, 'params': params}
        self.sendMessage(json.dumps(command))
        return deferred

    def onConnect(self, response):
        self.message_ids = itertools.count()
        self.requests = {}
        self.deferreds = {}
        self.cpu_times = []
        self.wall_times = []

    def onOpen(self):
        logging.info('Loading %s...', highlight(self.factory.target_url))

        deferreds = defer.DeferredList((
            self.sendCommand('Page.enable'),
            self.sendCommand('Network.enable'),
            self.sendCommand('Profiler.enable'),
            self.sendCommand('Page.addScriptToEvaluateOnLoad',
                             scriptSource=JS),
            self.sendCommand('Profiler.setSamplingInterval', interval=100),
        ))

        if self.factory.display:
            deferreds.chainDeferred(self.sendCommand(
                'Page.setDeviceMetricsOverride', **self.factory.display))

        if self.factory.latency:
            deferreds.chainDeferred(self.sendCommand(
                'Network.emulateNetworkConditions', offline=False, latency=100,
                downloadThroughput=262144, uploadThroughput=262144))

        return deferreds.addCallback(self.onProfilerReady)

    def onNetworkRequestServedFromCache(self, params=None):
        del self.requests[params['requestId']]

    def onNetworkRequestWillBeSent(self, params=None):
        self.requests[params['requestId']] = params['request']

    def onProfilerReady(self, params=None):
        self.sendCommand('Network.clearBrowserCache')
        self.sendCommand('Page.navigate', url=self.factory.target_url)

    def writeProfilerData(self, data):
        name = '%s.%d.cpuprofile' % (data.get('title', 'profile'), time.time())
        with open(name, 'w') as f:
            json.dump(data, f)

    def onProfilerConsoleProfileStarted(self, params=None):
        self.requests.clear()

    def onProfilerConsoleProfileFinished(self, params=None):
        data = params['profile']

        if self.factory.write:
            self.writeProfilerData(data)

        profile = ChromeCPUProfile(data)

        if self.factory.show_uncached_requests:
            for req in self.requests.values():
                logging.info('[%s] %s', highlight(req['method']), req['url'])

        if self.factory.warmups:
            self.factory.warmups -= 1
        else:
            self.cpu_times.append(profile.cpu_time)
            self.wall_times.append(profile.wall_time)

        reps = len(self.cpu_times)
        logging.info('{:02d}/{:02d}: CPU: {: >7.2f}  Wall: {: >7.2f}'.format(
            reps, self.factory.reps, profile.cpu_time, profile.wall_time))
        if reps < self.factory.reps:
            self.onProfilerReady()
        else:
            reactor.stop()
            self.showSummary()

    def getHandler(self, method):
        object, event = method.split('.')
        handler = 'on' + object + upper_first(event)
        return getattr(self, handler, None)

    def onMessage(self, payload, isBinary):
        message = json.loads(payload.decode('utf-8'))

        id = message.get('id')
        error = message.get('error')
        method = message.get('method')
        params = message.get('params')
        response = message.get('response')
        deferred = self.deferreds.get(id)

        if deferred:
            if error:
                log.error(error)
                return deferred.errback(error)
            else:
                return deferred.callback(response)

        if method:
            handler = self.getHandler(method)
            if handler:
                return handler(params)

    def showSummary(self):
        logging.info('CPU:  %s', format_summary(summarize(self.cpu_times)))
        logging.info('Wall: %s', format_summary(summarize(self.wall_times)))


class ChromeRemoteDebuggingFactory(WebSocketClientFactory):

    def __init__(self, url, host='localhost', port=9222, reps=20,
                 warmups=0, write=False, show_uncached_requests=False,
                 display=False, latency=False):
        self.host = host
        self.port = port
        self.reps = reps
        self.warmups = warmups
        self.target_url = url.replace('https://', 'http://', 1)  # force HTTP
        self.write = write
        self.show_uncached_requests = show_uncached_requests
        self.display = display
        self.latency = latency
        tab = next(t for t in self.getTabs() if 'webSocketDebuggerUrl' in t)
        WebSocketClientFactory.__init__(self, tab['webSocketDebuggerUrl'])
        self.protocol = ChromeRemoteDebuggingProtocol

    def getTabs(self):
        req = urllib2.urlopen('http://%s:%s/json' % (self.host, self.port))
        return json.load(req)


ap = argparse.ArgumentParser(fromfile_prefix_chars='@')
ap.add_argument('--host', default='localhost', help='Chromium host')
ap.add_argument('--port', default=9222, type=int, help='Chromium port')
ap.add_argument('--reps', default=20, metavar='N', type=int,
                help='repetitions')
ap.add_argument('--warmups', default=2, metavar='N', type=int,
                help='warm-up loops')
ap.add_argument('--show-uncached-requests', action='store_true', default=False,
                help='log uncached network requests')
ap.add_argument('--write', action='store_true', default=False,
                help='save profiling data as .cpuprofile files.')
ap.add_argument('--display', type=parse_display_opts,
                help='set device display metrics to WIDTHxHEIGHT*FACTOR.')
ap.add_argument('--latency', action='store_true', default=False,
                help='simulate realistic network conditions')
ap.add_argument('url', help='URL to load')
args = ap.parse_args()


if __name__ == '__main__':
    observer = log.PythonLoggingObserver()
    observer.start()
    factory = ChromeRemoteDebuggingFactory(**vars(args))
    reactor.connectTCP(args.host, args.port, factory)
    reactor.run()
