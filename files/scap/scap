#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Heterogeneous deployment script

Deploys MediaWiki code and configuration to a group of servers via rsync.

"""
import argparse
import contextlib
import fcntl
import imp
import logging
import os
import pipes
import random
import socket
import struct
import subprocess
import tempfile
import time



class IRCSocketHandler(logging.Handler):
    """Log handler for logmsgbot on #wikimedia-operation."""

    def __init__(self, host, port, timeout=1.0):
        super(IRCSocketHandler, self).__init__()
        self.addr = (host, port)
        self.level = logging.INFO
        self.timeout = timeout

    def emit(self, record):
        message = '!log %s %s' % (os.getlogin(), record.getMessage())
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect(self.addr)
            sock.sendall(message.encode('utf-8'))
            sock.close()
        except (socket.timeout, socket.error):
            self.handleError(record)


log = logging.getLogger('scap')
log.setLevel(logging.DEBUG)
log.addHandler(IRCSocketHandler('neon.wikimedia.org', 9200))
log.addHandler(logging.StreamHandler())


def shell_map(mapping):
    """Convert a map to a string of space-separated KEY=VALUE pairs."""
    return ' '.join('%s=%s' % (k, pipes.quote(v)) for k, v in mapping.items())


def get_config():
    """Load environment variables from mw-deployment-vars.sh."""
    dep_env = imp.load_source('__env', '/usr/local/lib/mw-deployment-vars.sh')
    return {k: v for k, v in dep_env.__dict__.items() if k.startswith('MW_')}


@contextlib.contextmanager
def lock(filename):
    """Context manager. Acquires a file lock on entry, releases on exit."""
    with open(filename, 'w+') as lock_fd:
        fcntl.lockf(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        try:
            yield
        finally:
            fcntl.lockf(lock_fd, fcntl.LOCK_UN)


def cdb_items(buf):
    """Iterates over CDB key/value pairs."""
    table_start, = struct.unpack_from('<L', buf)
    offset = 2048
    while offset < table_start:
        lengths = struct.unpack_from('<LL', buf, offset)
        offset += 8
        yield struct.unpack_from('%ds %ds' % lengths, buf, offset)
        offset += sum(lengths)


def get_branches(wikiversions_cdb_path):
    """Get the set of active branches from a wikiversions.cdb file."""
    with open(wikiversions_cdb_path, 'rb') as cdb_file:
        cdb = cdb_file.read()
        return {v for k, v in cdb_items(cdb) if k.startswith('ver:')}


def dsh(command, group, exports=None):
    """Run a command on multiple hosts via DSH."""
    if exports:
        command = '%s %s' % (shell_map(exports), command)
    group_file = os.path.join('/etc/dsh/group', group)
    return subprocess.check_call(['dsh', '-F40', '-cM', '-f', group_file, '-o',
                                  '-oSetupTimeout=10', '--', command.strip()])


def check_syntax(*paths):
    """Run lint.php on `paths`; raise CalledProcessError if nonzero exit."""
    command = ['/usr/bin/php', '-n', '-dextension=parsekit.so',
               '/usr/local/bin/lint.php'] + list(paths)
    return subprocess.check_call(command)


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='Deploy MediaWiki')
    parser.add_argument('--active', action='store_true', default=False,
                        help='only sync active branches')
    parser.add_argument('message', nargs=argparse.REMAINDER)
    return parser.parse_args()


def scap():
    """Deploy MediaWiki code and configuration."""
    if 'SSH_AUTH_SOCK' not in os.environ:
        raise RuntimeError('SSH_AUTH_SOCK is unset. Is your agent running?')

    start = time.time()
    config = get_config()
    env = {}
    args = parse_args()
    if args.active:
        branches = get_branches('%(MW_COMMON)s/wikiversions.cdb' % config)
        env['MW_VERSIONS_SYNC'] = ' '.join(branches)

    with lock('/var/lock/scap'):
        # Perform syntax check
        log.debug('Checking syntax of wmf-config and multiversion')
        check_syntax('%(MW_COMMON_SOURCE)s/wmf-config' % config)
        check_syntax('%(MW_COMMON_SOURCE)s/multiversion' % config)

        # Update the current machine so that serialization works.
        # Push wikiversions.dat changes so mwversionsinuse, set-group-write,
        # and mwscript work with the right version of the files.
        subprocess.check_call('/usr/local/bin/sync-common')

        # Update list of extension message files and regenerate
        # the localisation cache
        subprocess.check_call('/usr/local/bin/mw-update-l10n')

        # Notify
        log.info('started scap: %s', args.message)

        log.debug('updating rsync proxies')
        dsh('/usr/local/bin/scap-1', 'scap-proxies', env)

        with open('/etc/dsh/group/scap-proxies') as f:
            rsync_servers = ' '.join(
                ln.strip() for ln in f if not ln.startswith('#'))

        with open('/etc/dsh/group/mediawiki-installation', 'rt') as f:
            # Randomize the order of target machines
            hosts = random.shuffle(ln for ln in f if not ln.startswith('#'))
            with tempfile.NamedTemporaryFile(prefix='scap') as tmp:
                tmp.write(''.join(hosts))
                log.debug('copying code to apaches')
                dsh('/usr/local/bin/scap-1 "%s"' % rsync_servers,
                    tmp.name, env)

                log.debug('rebuilding CDB files from /upstream')
                dsh('/usr/local/bin/scap-rebuild-cdbs', tmp.name, env)

        # Builds wikiversions.cdb and syncs it to the apaches with the dat
        # file. This is done after all else so that deploying new MW versions
        # is easier.
        subprocess.check_call('sync-wikiversions')

    stop = time.time()
    duration = '%02dm %02ds' % divmod(stop - start, 60)
    log.info('finished scap: %s (duration: %s)', args.message, duration)
    # TODO: record scap in graphite


if __name__ == '__main__':
    scap()
