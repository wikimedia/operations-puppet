#!/usr/bin/env python

import os, sys, urllib2, sqlite3
import xml.etree.ElementTree as ET
from optparse import OptionParser

cmd_parser = OptionParser(version = '%prog 1.0')
cmd_parser.add_option('-q', '--qps', action = 'store', dest = 'qps', help = 'Check requests per second')
cmd_parser.add_option('-a', '--avgtime', action = 'store', dest = 'request_time', help = 'Check average request time')
cmd_parser.add_option('-H', '--host', type = 'string', action = 'store', dest = 'host', help = 'Solr host', default = 'localhost')
cmd_parser.add_option('-p', '--port', type = 'string', action = 'store', dest = 'port', help = 'Solr port', default = '8983')
cmd_parser.add_option('-t', '--timeout', type = 'int', action = 'store', dest = 'timeout', help = 'Timeout in seconds', default = 3)
(cmd_options, cmd_args) = cmd_parser.parse_args()

errors = []
warnings = []
unknowns = []
messages = []

db_conn = None

def http_get(path):
	url = 'http://' + cmd_options.host + ':' + cmd_options.port + '/solr/' + path
	return urllib2.urlopen(url, None, cmd_options.timeout).read()

def check_value(value, limits, message):
	value = float(value)
	limits = limits.split(':')
	if value > float(limits[0]):
		errors.append(message % (value, limits[0]))
	elif len(limits) > 1 and value > float(limits[1]):
		warnings.append(message % (value, limits[1]))

def check_stat(entry, stat, limits, stat_name):
	if limits == None: return
	node = entry.find(".//stats/stat[@name='%s']" % stat)
	if node != None:
		check_value(node.text, limits, stat_name + ' is %s (gt %s)')
	else:
		unknowns.append('Parameter "%s" not found in response' % stat)

def check_select(entry):
	check_stat(entry, 'avgTimePerRequest', cmd_options.request_time, 'Average request time')
	check_stat(entry, 'avgRequestsPerSecond', cmd_options.request_time, 'Average requests per second')

def check_error_metric(entry, metric):
	what = entry.find('name').text.strip()
	count = int(entry.find(".//stats/stat[@name='%s']" % metric).text)
	consecutive = 0
	save = False
	c = db_conn.cursor()
	c.execute('SELECT count, consecutive FROM errors WHERE host=? AND what=? AND metric=?',\
		(cmd_options.host, what, metric))
	res = c.fetchone()
	if res:
		(prev_count, consecutive) = res
		prev_count = int(prev_count)
		if count != prev_count:
			if count > prev_count:
				consecutive += 1
				if consecutive == 1:
					warnings.append('%d new errors on %s' % (count - prev_count, what))
				else:
					errors.append('New errors on %s %d times in a row'  % (what, consecutive))
			save = True
		elif consecutive > 0:
			consecutive = 0
			save = True
	else: # No previous data from DB
		save = True
	if save:
		c.execute('INSERT OR REPLACE INTO errors VALUES (?, ?, ?, ?, ?)',\
			(cmd_options.host, what, metric, count, consecutive))
		db_conn.commit()

def check_handler_errors(entry):
	global db_conn
	if db_conn == None:
		db_conn = sqlite3.connect('/var/lib/check_solr/checks.sqlite3')
		c = db_conn.cursor()
		c.execute("SELECT * FROM sqlite_master WHERE tbl_name='errors' LIMIT 1")
		if len(c.fetchone()) == 0:
			c.execute("CREATE TABLE errors(\
				host TEXT,\
				what TEXT,\
				metric TEXT,\
				count INTEGER,\
				consecutive INTEGER,\
				PRIMARY KEY(host, what, metric)\
				)")

	check_error_metric(entry, 'errors')
	check_error_metric(entry, 'timeouts')
				

def check_all_stats():
	text = http_get('admin/stats.jsp')
	xml = ET.fromstring(text)

	for entry in xml.iter('entry'):
		name = entry.find('name').text.strip()
		if name == '/select':
			check_select(entry)
			#check_handler_errors(entry)
		elif name == '/admin/ping':
			check_handler_errors(entry)

def process_results():
	if len(errors):
		print '; '.join(errors)
		return 2
	elif len(unknowns):
		print '; '.join(unknowns)
		return 3
	elif len(warnings):
		print '; '.join(warnings)
		return 1

	return 0

#try:
check_all_stats()
#except Exception:
#unknowns.append('Shit hit fan')

exit(process_results())

