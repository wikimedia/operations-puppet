#!/usr/bin/perl -w
#===============================================================================
#
#         FILE: check_dispatch
#
#        USAGE: check_dispatch -H http://www.wikidata.org
#
#  DESCRIPTION: nagios plugin to check dispatch stats on Wikidata.  
#               Retrieves newest change timestamp and diffs against current time.  
#               Also, retrieves average lag and puts it in a performance label 
#               tag for Nagios.
#
#      OPTIONS: ---
# REQUIREMENTS: WWW::Mechanize, JSON , JSON::Path , DateTime::Format::Duration, 
#               DateTime::Format::Strptime 
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Christopher Johnson, christopher.johnson@wikimedia.de
#      COMPANY:
#      VERSION: 0.1
#      CREATED: 
#     REVISION: ---
#===============================================================================

use strict;
use warnings;

#time calculations
use DateTime;
use DateTime::Format::Duration;
use DateTime::Format::Strptime;

# load libwww module
use LWP;

# load JSON module
use JSON;
use JSON::Path;

# load Getopt::Long module for cli arguments
use Getopt::Long;

# load nagios utils module 
#use lib utils.pm;
#use utils qw(%ERRORS);

# load Pod::Usage module for automatic documentation
use Pod::Usage;

# Mechanize calls the server
use WWW::Mechanize;

#Data Dump for Mech Response
use Data::Dumper::Simple;

#Storable for persistance (option) 
#use Storable qw( freeze thaw );

#-------------------------------------------------------------------------------
# GLOBAL VARIABLES
#-------------------------------------------------------------------------------
# this hash is provided by module utils if nagios is present
my %ERRORS=('OK'=>0,'WARNING'=>1,'CRITICAL'=>2,'UNKNOWN'=>3,'DEPENDENT'=>4);

# check user-agent
my $agent = "nagios check_dispatch";

# save content-type header to validate json
my $header = undef;

# mediawiki url 
my $siteurl = undef;    # this has to be a cli argument

# url for api call to site statistics
my $apiurl = "/w/api.php?action=query&meta=siteinfo&format=json&siprop=statistics";

# concatenate base url and api url

# static JSON paths to request metric keys
my @paths = ('query.statistics.dispatch.newest.timestamp','query.statistics.dispatch.average.lag');

my $debug    = undef;
my $response = undef;
my $help     = undef;
my $version  = "0.1";
my $realm    = undef;
my $netloc   = undef;
my $user     = undef;
my $passwd   = undef;
my $revision = undef;
my $content = undef;
my $critical = 10;
#-------------------------------------------------------------------------------
# process cli arguments
#-------------------------------------------------------------------------------
Getopt::Long::Configure( "no_ignore_case", "bundling" );
GetOptions(
    'H|hostname=s' => \$siteurl,
    'n|netloc=s'   => \$netloc,
    'r|realm=s'    => \$realm,
    'u|user=s'     => \$user,
    'p|passwd=s'   => \$passwd,
    'h|help|?'     => \$help,
    'v|verbose'    => \$debug,
    'V|version'    => \$revision,
    'c|critical=s'   => \$critical,
);

# give version if asked and exit
if ($revision) {
    print "$0 version: $version\n";
    exit $ERRORS{'OK'};
}

# if help chosen, display it
pod2usage( -verbose => 2, -noperldoc => 1, ) if $help;

# if no -H specified, show usage
pod2usage() unless $siteurl;

#-------------------------------------------------------------------------------
# start the check
#-------------------------------------------------------------------------------
# create a user agent object to show in the webserver logs
my $ua = LWP::UserAgent->new;
$ua->agent($agent);

# do not wait for ever, after 20 seconds give up
$ua->timeout(20);

if ( defined $debug ) {
    $ua->show_progress("true");
}

# concatenate base url and api url
my $fullurl = $siteurl . $apiurl;

# if we need to enter login info, else just get the url
if ( defined $user ) {
    $ua->credentials( $netloc, $realm, $user, $passwd );
    $response = $ua->get($fullurl);
}
else {
    $response = $ua->head($fullurl);
}

# if the web request is succesful, proceed with check. Else exit with warning.
if ( $response->is_success ) {

    $header = $response->header("Content-Type");

    die "could not get header\n" unless defined $header;

    # if the head request does not return the json content type, then die
    if ( $header =~ m/json./i  ) {
            print "API URL OK -";
    }
    else {
        print "WARNING: This does not look like the correct site\n";
        print "$header\n" if defined $header;
        exit $ERRORS{'WARNING'};
    }
}
else {
    print "WARNING: we got: ", $response->status_line,
      " when requesting $fullurl.
    Something went wrong fetching it.\n";
    exit $ERRORS{'WARNING'};
}

#-------------------------------------------------------------------------------
# call the API with Mechanize
#-------------------------------------------------------------------------------
# create new mechanize object without autocheck
my $mech = WWW::Mechanize->new( autocheck => 0, );

# set another user-agent, mediawiki.org blocks libwww-perl (if they think this
# helps ...)
$mech->agent($agent);

# show debugging if verbose is on
if ( defined $debug ) {
    $mech->show_progress(1);
}

# get the page
$mech->get($fullurl);

if ( $mech->success ) {
    my $content = $mech->content or Dumper $mech->response;

    #traverse JSON path and return values
    my @values;
    foreach my $path (@paths) {  
       my $jpath = JSON::Path->new($path);
       foreach my $i ($jpath) {
          my @value = $jpath->values($content);
          push @values, @value;
       }    
    }

    #change MW timestamp to readable format 
    my $timestamp = &format_timestamp($values[0]);
    #get time elapsed since last site change
    my $diff = &change_diff($values[0]);
    
    #output message to console
    print "Newest timestamp from the changes table is $timestamp , $diff ago | lag=  $values[1]s;3;", $critical, ";\n";
}
else {
    print "WARNING: webserver $fullurl returned ", $mech->status, "\n";
    exit $ERRORS{'WARNING'};
}

sub format_timestamp {
   #get the timestamp from the dispatch object
   my $date = $_[0];
   #create the MW timestamp input format
   my $strpin = DateTime::Format::Strptime->new( pattern   => '%Y%m%d%H%M%S');
   #put the timestamp in the DT object
   my $dtin = $strpin->parse_datetime($date);
   #create the MW timestamp output format
   my $strpout = DateTime::Format::Strptime->new( pattern   => '%F %T');
   #create the dt in the output format
   $strpout->format_datetime($dtin);
}

sub change_diff {
   #get the timestamp from the dispatch object
   my $date = $_[0];
   #create the MW timestamp format
   my $strp = DateTime::Format::Strptime->new( pattern   => '%Y%m%d%H%M%S');
   #put the current time in the DT object with the MW format
   my $dt1 = DateTime->now( formatter => $strp);
   #put the timestamp in the DT object
   my $dt2 = $strp->parse_datetime($date);
   #calculate the duration
   my $duration = $dt1 - $dt2;
   #output the calculation in the format
   my $format = DateTime::Format::Duration->new( pattern => '%M minutes, %S seconds' );
   $format->format_duration($duration);
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#  Application Documentation
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

=head1 NAME

check_dispatch - check dispatch stats 

=head1 VERSION

This documentation refers to <check_dispatch>

=head1 USAGE

check_dispatch -H http://www.example.com [-v true] [-n netlocation -r
realm -u username -p password

=head1 REQUIRED ARGUMENTS

-H|--hostname
web address of site hosting the mediawiki site;

=head1 OPTIONS

-H|--hostname
web address of site hosting the mediawiki site;

-n|--netloc
hostname:port combination for webserver dns hostname. *NO* protocol (no
http:// in it), just a simple or fully qualified name plus the port number.

-r|--realm
authentication realm; this is case sensitive.

-u|--username

-p|--password

-v|--verbose
standard this setting is 'false'. If 'true', then one can see extra debugging
info of the http request;

-c|--critical
max threshold for critical lag performance status

-h|--help
this text;

=head1 DESCRIPTION

Nagios check to monitor dispatch stats via the Wikidata API

When using this check for password protected sites (those where the webserver
sends a 401 answer code and a pop up browser window requests us to enter a
username/password combination), we need to enter in fact four arguments: the
netloc, username, password and realm.

The netloc (this is the name the libwww gives it) is a string formed by a
combination of the dns hostname followed by ':' and then by a number. The
number represents the port used by the webserver, usually 80. So the netloc
for the site http://www.example.com would be www.example.com:80, without the
http:// part which refers to the web protocol.

For the other 3 arguments (realm, username and password) please refer to
http://en.wikipedia.org/wiki/Basic_access_authentication 

=head1 DIAGNOSTICS

This check can fail because of network problems. Use the --verbose
true parameter to get better information if it fails.

=head1 CONFIGURATION AND ENVIRONMENT

Place the plugin in the plugin directory of the nagios server (usually,
/usr/local/nagios/libexec/), make the nagios user its owner and change the
permissions to 775.  Also, see the check_dispatch.cfg file.

For Puppet, see the icinga.pp manifest.  
This requires  a party Perl module and the Example42/Puppi module
See git clone https://github.com/example42/puppi.git /etc/puppet/modules/puppi

=head1 DEPENDENCIES

This plugin requires the WWW::Mechanize module, JSON::Path and several DateTime modules

=head1 INCOMPATIBILITIES

None known yet.

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR
Christopher H. Johnson

=head1 LICENCE AND COPYRIGHT

You can redistribute and/or modify this software under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 3 of the License, or (at your option) any later
version; with the additional exemption that compiling, linking, and/or using OpenSSL is allowed.

This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the COPYING file for the complete text of the GNU General Public License, version 3.
=cut

